<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - Interact.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>Interact.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">921</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">127.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.89</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(global, factory) {
    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        define([&#039;exports&#039;, &#039;jquery&#039;, &#039;./Point.js&#039;], factory);
    } else if (typeof exports !== &quot;undefined&quot;) {
        factory(exports, require(&#039;jquery&#039;), require(&#039;./Point.js&#039;));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.jquery, global.Point);
        global.Interact = mod.exports;
    }
})(this, function(exports, _jquery, _Point) {
    &#039;use strict&#039;;

    Object.defineProperty(exports, &quot;__esModule&quot;, {
        value: true
    });
    exports.Interact = undefined;

    var _jquery2 = _interopRequireDefault(_jquery);

    function _interopRequireDefault(obj) {
        return obj &amp;&amp; obj.__esModule ? obj : {
            default: obj
        };
    }

    var _typeof = typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot; ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol ? &quot;symbol&quot; : typeof obj;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError(&quot;Cannot call a class as a function&quot;);
        }
    }

    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i &lt; props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if (&quot;value&quot; in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    var Interact = exports.Interact = function() {
        _createClass(Interact, [{
            key: &#039;isMouse&#039;,


            /**
             * checks if mouse is possible
             * @return {Boolean} if true, mouse is possible
             */
            get: function get() {
                return &#039;onmousedown&#039; in window;
            }

            /**
             * checks if touch is possible
             * @return {Boolean} if true, touch is possible
             */

        }, {
            key: &#039;isTouch&#039;,
            get: function get() {
                return &#039;ontouchstart&#039; in window || navigator.MaxTouchPoints &gt; 0 || navigator.msMaxTouchPoints &gt; 0;
            }

            /**
             * checks if IE is used
             * @return {Boolean} if true, IE is used
             */

        }, {
            key: &#039;isIE&#039;,
            get: function get() {
                return navigator.MaxTouchPoints &gt; 0 || navigator.msMaxTouchPoints &gt; 0;
            }

            /**
             * gets cross-browser scroll-event
             * @return {string} name of scroll event
             */

        }, {
            key: &#039;scrollEvent&#039;,
            get: function get() {
                return &quot;onwheel&quot; in document.createElement(&quot;div&quot;) ? &quot;wheel&quot; : document.onmousewheel !== undefined ? &quot;mousewheel&quot; : &quot;DOMMouseScroll&quot;;
            }

            /**
             * Constructor
             * @param {Object} settings = {} - all the settings
             * @param {string|Object} settings.container = &quot;.interact-container&quot; - Container, either string, jQuery-object or dom-object
             * @param {Object} settings.timeTreshold = {} - settings for the timing tresholds
             * @param {number} settings.timeTreshold.tap = 200 - timing treshold for tap
             * @param {number} settings.timeTreshold.hold = 500 - timing treshold for hold
             * @param {number} settings.timeTreshold.swipe = 300 - timing treshold for swipe
             * @param {number} settings.timeTreshold.flick = 30 - timing treshold for flick
             * @param {Object} settings.distanceTreshold = {} - settings for the distance tresholds
             * @param {number} settings.distanceTreshold.swipe = 200 - distance treshold for swipe
             * @param {Boolean|string} settings.overwriteViewportSettings = false - on true prevents pinching, can be a custom string too
             * @param {Boolean} settings.stopPropagation = true - on true stops the propagation of events
             * @param {Boolean} settings.preventDefault = true - on true prevents the default actions of events
             * @param {Boolean} settings.autoFireHold = false - if set to false hold-event is not fired
             * @param {number} settings.pinchBalanceTime = 50 - prevents from firing too much pinching events
             * @param {Object} settings.callbacks = {} - settings for the callback-functions
             * @param {function} settings.callbacks.tap = null - callback-function for tap
             * @param {function} settings.callbacks.tapHold = null - callback-function for tapHold
             * @param {function} settings.callbacks.doubletap = null - callback-function for doubletap
             * @param {function} settings.callbacks.hold = null - callback-function for hold
             * @param {function} settings.callbacks.pan = null - callback-function for pan
             * @param {function} settings.callbacks.swipe = null - callback-function for swipe
             * @param {function} settings.callbacks.flick = null - callback-function for flick
             * @param {function} settings.callbacks.zoom = null - callback-function for zoom
             * @param {function} settings.callbacks.wheel = null - callback-function for wheel
             * @param {function} settings.callbacks.pinch = null - callback-function for pinch
             * @param {Object} settings.events = {} - settings all eventnames
             * @param {Object} settings.events.start = {} - settings all start eventnames
             * @param {Object} settings.events.start.touch = (&quot;MSPointerDown pointerdown&quot; || &quot;touchstart&quot;) - settings start touch eventnames
             * @param {Object} settings.events.start.mouse = (&quot;MSPointerDown pointerdown&quot; || &quot;mousedown&quot;) - settings start mouse eventnames
             * @param {Object} settings.events.move = {} - settings all move eventnames
             * @param {Object} settings.events.move.touch = (&quot;MSPointerMove pointermove&quot; || &quot;touchmove&quot;) - settings move touch eventnames
             * @param {Object} settings.events.move.mouse = (&quot;MSPointerMove pointermove&quot; || &quot;mousemove&quot;) - settings move mouse eventnames
             * @param {Object} settings.events.end = {} - settings all end eventnames
             * @param {Object} settings.events.end.touch = (&quot;MSPointerUp pointerup&quot; || &quot;touchend&quot;) - settings end touch eventnames
             * @param {Object} settings.events.end.mouse = (&quot;MSPointerUp pointerup&quot; || &quot;mouseup&quot;) - settings end mouse eventnames
             * @param {Object} settings.events.leave = {} - settings all leave eventnames
             * @param {Object} settings.events.leave.touch = (&quot;MSPointerLeave pointerleave&quot; || &quot;touchleave&quot;) - settings leave touch eventnames
             * @param {Object} settings.events.leave.mouse = (&quot;MSPointerLeave pointerleave&quot; || &quot;mouseleave&quot;) - settings leave mouse eventnames
             * @param {string} settings.events.scroll = (&quot;wheel&quot; || &quot;mousewhell&quot; || &quot;DOMMouseScroll&quot;) - settings all scroll eventnames
             * @return {Interact} new instance
             */

        }]);

        function Interact() {
            var settings = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

            _classCallCheck(this, Interact);

            this.settings = {
                container: &quot;.interact-container&quot;,
                timeTreshold: {
                    tap: 200,
                    hold: 500,
                    swipe: 300,
                    flick: 30
                },
                distanceTreshold: {
                    swipe: 200
                },
                overwriteViewportSettings: false,
                stopPropagation: true,
                preventDefault: true,
                autoFireHold: false,
                pinchBalanceTime: 50,
                callbacks: {
                    tap: null,
                    tapHold: null,
                    doubletap: null,
                    hold: null,
                    pan: null,
                    swipe: null,
                    flick: null,
                    zoom: null,
                    wheel: null,
                    pinch: null
                },
                events: {
                    start: {
                        touch: this.isIE ? &quot;MSPointerDown pointerdown&quot; : &quot;touchstart&quot;,
                        mouse: this.isIE ? &quot;MSPointerDown pointerdown&quot; : &quot;mousedown&quot;
                    },
                    move: {
                        touch: this.isIE ? &quot;MSPointerMove pointermove&quot; : &quot;touchmove&quot;,
                        mouse: this.isIE ? &quot;MSPointerMove pointermove&quot; : &quot;mousemove&quot;
                    },
                    end: {
                        touch: this.isIE ? &quot;MSPointerUp pointerup&quot; : &quot;touchend&quot;,
                        mouse: this.isIE ? &quot;MSPointerUp pointerup&quot; : &quot;mouseup&quot;
                    },
                    leave: {
                        touch: this.isIE ? &quot;MSPointerLeave pointerleave&quot; : &quot;touchleave&quot;,
                        mouse: this.isIE ? &quot;MSPointerLeave pointerleave&quot; : &quot;mouseleave&quot;
                    },
                    scroll: this.scrollEvent
                }
            };

            _jquery2.default.extend(true, this.settings, settings || {});

            this.isDown = false;
            this.hasMoved = false;
            this.multitouch = false;
            this.lastAction = null;
            this.start = null;
            this.move = null;
            this.end = null;
            this.time = null;
            this.timeStart = null;
            this.timeEnd = null;
            this.timeout = null;
            this.holdTimeout = null;
            this.wasPinched = false;
            this.pointerIDs = {};

            if (this.settings.overwriteViewportSettings) {
                this.handleViewport(this.settings.overwriteViewportSettings);
            }

            this.init(this.settings.container).bindEvents();
        }

        /**
         * handles the overwrite of viewport meta
         * @param  {Boolean|string} viewport - specified viewport option
         * @return {Interact} Returns this instance
         */


        _createClass(Interact, [{
            key: &#039;handleViewport&#039;,
            value: function handleViewport(viewport) {
                if (typeof viewport !== &quot;string&quot;) {
                    viewport = &quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;;
                }
                var metaViewInHead = (0, _jquery2.default)(&quot;meta[name=viewport]&quot;).length,
                    $viewportMeta = metaViewInHead !== 0 ? (0, _jquery2.default)(&quot;meta[name=viewport]&quot;) : (0, _jquery2.default)(&quot;head&quot;).append((0, _jquery2.default)(&quot;&lt;meta name=&#039;viewport&#039; /&gt;&quot;));
                $viewportMeta.attr(&quot;content&quot;, viewport);
                return this;
            }

            /**
             * initializes class settings and bindings
             * @param  {Object|string} container - Container, either string, jQuery-object or dom-object
             * @return {Interact} Returns this instance
             */

        }, {
            key: &#039;init&#039;,
            value: function init(container) {
                this.$container = typeof container === &quot;string&quot; ? (0, _jquery2.default)(container) : (typeof container === &#039;undefined&#039; ? &#039;undefined&#039; : _typeof(container)) === &quot;object&quot; &amp;&amp; container instanceof jQuery ? container : (0, _jquery2.default)(container);
                if (!(this.$container instanceof jQuery)) {
                    throw new Error(&quot;Container &quot; + container + &quot; not found&quot;);
                }
                this.$container.css({
                    &quot;-ms-touch-action&quot;: &quot;none&quot;,
                    &quot;touch-action&quot;: &quot;none&quot;,
                    &quot;-ms-content-zooming&quot;: &quot;none&quot;
                });
                this.container = this.$container[0];
                return this;
            }

            /**
             * binds all needed events
             * @return {Interact} Returns this instance
             */

        }, {
            key: &#039;bindEvents&#039;,
            value: function bindEvents() {
                if (this.isIE) {
                    this.bindIEEvents();
                } else {
                    if (this.isTouch) {
                        this.bindTouchEvents();
                    }
                    if (this.isMouse) {
                        this.bindMouseEvents();
                    }
                }
                return this;
            }

            /**
             * binds all needed events for IE
             * @return {Interact} Returns this instance
             */

        }, {
            key: &#039;bindIEEvents&#039;,
            value: function bindIEEvents() {
                this.$container.on(this.settings.events.scroll, this.scrollHandler.bind(this));
                this.bindTouchEvents();
                this.container.addEventListener(&quot;contextmenu&quot;, function(e) {
                    e.preventDefault();
                }, false);
                return this;
            }

            /**
             * binds all needed events for touch devices
             * @return {Interact} Returns this instance
             */

        }, {
            key: &#039;bindTouchEvents&#039;,
            value: function bindTouchEvents() {
                this.$container.on(this.settings.events.start.touch, this.startHandler.bind(this)).on(this.settings.events.move.touch, this.moveHandler.bind(this)).on(this.settings.events.end.touch, this.endHandler.bind(this)).on(this.settings.events.leave.touch, this.endHandler.bind(this));
                return this;
            }

            /**
             * binds all needed events for mouse devices
             * @return {Interact} Returns this instance
             */

        }, {
            key: &#039;bindMouseEvents&#039;,
            value: function bindMouseEvents() {
                this.$container.on(this.settings.events.scroll, this.scrollHandler.bind(this)).on(this.settings.events.start.mouse, this.startHandler.bind(this)).on(this.settings.events.move.mouse, this.moveHandler.bind(this)).on(this.settings.events.end.mouse, this.endHandler.bind(this)).on(this.settings.events.leave.mouse, this.endHandler.bind(this));
                return this;
            }

            /**
             * handles cross-browser and -device scroll
             * @param  {Object} event - jQuery-Event-Object
             * @return {Boolean} always returns false
             */

        }, {
            key: &#039;scrollHandler&#039;,
            value: function scrollHandler(event) {
                event = event || window.event;

                if (this.settings.stopPropagation) {
                    event.stopPropagation();
                }
                if (this.settings.preventDefault) {
                    event.preventDefault();
                }

                var e = this.getEvent(event) || event.originalEvent,
                    directions = this.getScrollDirection(e),
                    position = this.getRelativePosition(e);

                if (this.settings.callbacks.wheel) {
                    this.eventCallback(this.settings.callbacks.wheel, {
                        target: event.target,
                        directions: directions,
                        position: position
                    });
                }

                if (this.settings.callbacks.zoom &amp;&amp; (directions.indexOf(&quot;up&quot;) &gt; -1 || directions.indexOf(&quot;down&quot;) &gt; -1)) {
                    this.eventCallback(this.settings.callbacks.zoom, {
                        target: event.target,
                        direction: directions.indexOf(&quot;up&quot;) &gt; -1 ? &quot;in&quot; : directions.indexOf(&quot;down&quot;) &gt; -1 ? &quot;out&quot; : &quot;none&quot;,
                        position: position,
                        factor: directions.indexOf(&quot;up&quot;) &gt; -1 ? 1 : directions.indexOf(&quot;down&quot;) &gt; -1 ? -1 : 0
                    });
                }

                return false;
            }

            /**
             * handles cross-browser and -device start-event
             * @param  {Object} event - jQuery-Event-Object
             * @return {Boolean} always returns false
             */

        }, {
            key: &#039;startHandler&#039;,
            value: function startHandler(event) {

                if (this.settings.stopPropagation) {
                    event.stopPropagation();
                }
                if (this.settings.preventDefault) {
                    event.preventDefault();
                }

                if (event.button &amp;&amp; event.button !== 0) {
                    return false;
                }

                var e = this.getEvent(event);

                this.target = event.target;
                this.isDown = true;
                this.timeStart = event.timeStamp;

                if (this.timeout) {
                    this.timeout = clearTimeout(this.timeout);
                }

                // mouse is used
                if (e instanceof MouseEvent) {
                    this.start = this.getRelativePosition(e);
                } // if is pointerEvent
                if (this.isIE &amp;&amp; (e instanceof MSPointerEvent || e instanceof PointerEvent)) {
                    this.pointerIDs[e.pointerId] = e;
                    if (Object.keys(this.pointerIDs).length &lt;= 1) {
                        this.start = this.getRelativePosition(e);
                        this.multitouch = false;
                    } else {
                        this.multitouch = true;
                        var pointerPos = [];
                        for (var pointer in this.pointerIDs) {
                            if (this.pointerIDs.hasOwnProperty(pointer)) {
                                pointerPos.push(this.pointerIDs[pointer]);
                            }
                        }
                        var pointerPos1 = this.getRelativePosition(pointerPos[0]),
                            pointerPos2 = this.getRelativePosition(pointerPos[1]);

                        this.current.distance = pointerPos1.distance(pointerPos2);
                        this.start = pointerPos1.add(pointerPos2).divide(2, 2);
                    }
                } // touch is used
                else {
                    // singletouch startet
                    if (e.length &lt;= 1) {
                        this.start = this.getRelativePosition(e[0]);
                    } // multitouch started
                    else if (e.length === 2) {
                        this.multitouch = true;
                        var pos1 = this.getRelativePosition(e[0]),
                            pos2 = this.getRelativePosition(e[1]);
                        this.current.distance = pos1.distance(pos2);
                        this.start = pos1.add(pos2).divide(2, 2);
                    }
                }
                switch (this.lastAction) {
                    case null:
                        this.lastAction = &quot;tap&quot;;
                        if (this.settings.autoFireHold) {
                            this.setTimeoutForEvent(this.settings.callbacks.hold, this.settings.autoFireHold, {
                                target: this.target,
                                positions: {
                                    start: this.start
                                }
                            }, true);
                        }
                        break;
                    case &quot;tap&quot;:
                        this.lastAction = &quot;doubletap&quot;;
                        if (this.settings.autoFireHold) {
                            this.setTimeoutForEvent(this.settings.callbacks.tapHold, this.settings.autoFireHold, {
                                target: this.target,
                                positions: {
                                    start: this.start
                                }
                            }, true);
                        }
                        break;
                    default:
                        break;
                }

                return false;
            }

            /**
             * handles cross-browser and -device move-event
             * @param  {Object} event - jQuery-Event-Object
             * @return {Boolean} always returns false
             */

        }, {
            key: &#039;moveHandler&#039;,
            value: function moveHandler(event) {

                if (this.settings.stopPropagation) {
                    event.stopPropagation();
                }
                if (this.settings.preventDefault) {
                    event.preventDefault();
                }

                // if touchstart event was not fired
                if (!this.isDown || this.wasPinched) {
                    return false;
                }

                var e = this.getEvent(event),
                    currentPos = void 0,
                    currentDist = void 0,
                    lastPos = this.move ? this.move : this.start,
                    lastTime = this.time ? this.time : this.timeStart,
                    currentTime = event.timeStamp;

                if (this.isIE &amp;&amp; (this.getRelativePosition(e).equals(lastPos) || this.getRelativePosition(e).equals(this.start))) {
                    return false;
                } else if (!this.isIE &amp;&amp; this.isTouch &amp;&amp; this.getRelativePosition(e[0]).equals(lastPos)) {
                    return false;
                }

                if (this.timeout) {
                    this.timeout = clearTimeout(this.timeout);
                }
                if (this.holdTimeout) {
                    this.holdTimeout = clearTimeout(this.holdTimeout);
                }

                this.hasMoved = true;
                this.lastAction = &quot;move&quot;;

                this.time = event.timeStamp;

                if (e instanceof MouseEvent) {
                    currentPos = this.getRelativePosition(e);
                    currentDist = lastPos.distance(currentPos);
                } // if is pointerEvent
                if (this.isIE &amp;&amp; (e instanceof MSPointerEvent || e instanceof PointerEvent)) {
                    this.pointerIDs[e.pointerId] = e;
                    if (Object.keys(this.pointerIDs).length &lt;= 1) {
                        currentPos = this.getRelativePosition(e);
                        currentDist = lastPos.distance(currentPos);
                        this.multitouch = false;
                    } else {
                        this.multitouch = true;
                        var pointerPos = [];
                        for (var pointer in this.pointerIDs) {
                            if (this.pointerIDs.hasOwnProperty(pointer)) {
                                pointerPos.push(this.pointerIDs[pointer]);
                            }
                        }
                        var pointerPos1 = this.getRelativePosition(pointerPos[0]),
                            pointerPos2 = this.getRelativePosition(pointerPos[1]);

                        currentDist = pointerPos1.distance(pointerPos2);
                        currentPos = pointerPos1.substract(pointerPos2).divide(2, 2);
                    }
                } // touch is used
                else {
                    // singletouch startet
                    if (e.length &lt;= 1) {
                        currentPos = this.getRelativePosition(e[0]);
                        currentDist = lastPos.distance(currentPos);
                    } else if (e.length === 2) {
                        var pos1 = this.getRelativePosition(e[0]),
                            pos2 = this.getRelativePosition(e[1]);
                        currentDist = pos1.distance(pos2);
                        currentPos = pos1.substract(pos2).divide(2, 2);
                    }
                }

                var timeDiff = currentTime - lastTime;

                if (this.multitouch) {
                    this.current.difference = currentDist - this.current.distance;
                    this.current.distance = currentDist;
                    this.oldMove = this.move;
                    this.move = currentPos;
                    if (this.settings.callbacks.pinch &amp;&amp; this.current.difference !== 0) {
                        this.eventCallback(this.settings.callbacks.pinch, {
                            target: event.target,
                            positions: {
                                start: this.start,
                                current: this.move,
                                last: this.oldMove
                            },
                            distance: {
                                current: currentDist,
                                differenceToLast: this.current.difference
                            }
                        });
                    }
                    if (this.settings.callbacks.zoom &amp;&amp; this.current.difference !== 0) {
                        this.eventCallback(this.settings.callbacks.zoom, {
                            target: event.target,
                            positions: {
                                start: this.start,
                                current: this.move,
                                last: this.oldMove
                            },
                            direction: this.current.difference &lt; 0 ? &quot;out&quot; : this.current.difference &gt; 0 ? &quot;in&quot; : &quot;none&quot;,
                            factor: this.current.difference
                        });
                    }
                } else {
                    this.speed = this.calculateSpeed(currentDist, timeDiff);

                    this.oldMove = this.move;
                    this.move = currentPos;

                    this.eventCallback(this.settings.callbacks.pan, {
                        target: this.target,
                        positions: {
                            start: this.start,
                            current: this.move,
                            last: lastPos
                        },
                        timeElapsed: {
                            sinceLast: timeDiff,
                            sinceStart: currentTime - this.timeStart
                        },
                        distanceToLastPoint: currentDist,
                        speed: this.speed
                    });
                }

                return false;
            }

            /**
             * handles cross-browser and -device end-event
             * @param  {Object} event - jQuery-Event-Object
             * @return {Boolean} always returns false
             */

        }, {
            key: &#039;endHandler&#039;,
            value: function endHandler(event) {

                if (this.settings.stopPropagation) {
                    event.stopPropagation();
                }
                if (this.settings.preventDefault) {
                    event.preventDefault();
                }

                var e = this.getEvent(event);

                this.timeEnd = event.timeStamp;

                var timeDiff = this.timeEnd - this.timeStart,
                    timeDiffToLastMove = this.timeEnd - this.time;

                if (this.holdTimeout) {
                    this.holdTimeout = clearTimeout(this.holdTimeout);
                }

                if (e instanceof MouseEvent) {
                    this.end = this.getRelativePosition(e);
                } // if is pointerEvent
                if (this.isIE &amp;&amp; (e instanceof MSPointerEvent || e instanceof PointerEvent)) {
                    this.end = this.getRelativePosition(e);
                    delete this.pointerIDs[e.pointerId];
                } // touch is used
                else {
                    // singletouch ended
                    if (e.length &lt;= 1) {
                        this.end = this.getRelativePosition(e[0]);
                    }
                }

                // called only when not moved
                if (!this.hasMoved &amp;&amp; this.isDown &amp;&amp; !this.multitouch) {
                    switch (this.lastAction) {
                        case &quot;tap&quot;:
                            if (timeDiff &lt; this.settings.timeTreshold.hold) {
                                this.setTimeoutForEvent(this.settings.callbacks.tap, this.settings.timeTreshold.tap, {
                                    target: this.target,
                                    positions: {
                                        start: this.start
                                    }
                                });
                            } else {
                                this.eventCallback(this.settings.callbacks.hold, {
                                    target: this.target,
                                    positions: {
                                        start: this.start
                                    }
                                });
                            }
                            break;
                        case &quot;doubletap&quot;:
                            if (timeDiff &lt; this.settings.timeTreshold.hold) {
                                this.setTimeoutForEvent(this.settings.callbacks.doubletap, this.settings.timeTreshold.tap, {
                                    target: this.target,
                                    positions: {
                                        start: this.start,
                                        end: this.end
                                    }
                                });
                            } else {
                                this.eventCallback(this.settings.callbacks.tapHold, {
                                    target: this.target,
                                    positions: {
                                        start: this.start,
                                        end: this.end
                                    }
                                });
                            }
                            break;
                        default:
                            this.lastAction = null;
                    }
                }
                // if was moved
                else if (this.hasMoved &amp;&amp; this.isDown &amp;&amp; !this.multitouch) {

                    if (this.settings.callbacks.swipe || this.settings.callbacks.flick) {

                        var direction = this.settings.callbacks.swipe ? this.end.substract(this.start) : this.end.substract(this.oldMove);

                        var vLDirection = direction.length,
                            directionNormalized = direction.divide(vLDirection, vLDirection),
                            distance = this.end.distance(this.start),
                            speed = this.calculateSpeed(distance, timeDiff);

                        if (this.settings.callbacks.swipe &amp;&amp; timeDiff &lt;= this.settings.timeTreshold.swipe) {
                            var originalStart = this.getAbsolutePosition(this.start),
                                originalEnd = this.getAbsolutePosition(this.end);
                            if (originalEnd.distance(originalStart) &gt;= this.settings.distanceTreshold.swipe) {
                                var directions = this.getSwipeDirections(directionNormalized);
                                this.eventCallback(this.settings.callbacks.swipe, {
                                    positions: {
                                        start: this.start,
                                        end: this.end
                                    },
                                    speed: speed,
                                    directions: {
                                        named: directions,
                                        detailed: directionNormalized
                                    }
                                });
                            }
                        }

                        if (this.settings.callbacks.flick &amp;&amp; timeDiffToLastMove &lt;= this.settings.timeTreshold.flick) {
                            this.eventCallback(this.settings.callbacks.flick, {
                                speed: speed,
                                direction: directionNormalized,
                                positions: {
                                    start: this.start,
                                    end: this.end
                                }
                            });
                        }
                    }

                    switch (this.lastAction) {
                        default: this.lastAction = null;
                    }
                }

                if (this.multitouch) {
                    this.wasPinched = true;
                    setTimeout(function() {
                        this.wasPinched = false;
                    }.bind(this), this.settings.pinchBalanceTime);
                }

                this.multitouch = false;
                this.isDown = false;
                this.hasMoved = false;

                // if is pointerEvent
                if (this.isIE &amp;&amp; (e instanceof MSPointerEvent || e instanceof PointerEvent)) {
                    if (Object.keys(this.pointerIDs).length &gt; 1) {
                        this.multitouch = true;
                    } else if (Object.keys(this.pointerIDs).length &gt; 0) {
                        this.isDown = true;
                    }
                } // touch is used
                else {
                    if (e.length &gt; 1) {
                        this.multitouch = true;
                    } else if (e.length &gt; 0) {
                        this.isDown = true;
                    }
                    this.move = null;
                }

                return false;
            }

            /**
             * calculates the speed with specified distance and time
             * @param  {number} distance - the specified distance
             * @param  {number} time - the specified time elapsed
             * @return {number} the calculated speed
             */

        }, {
            key: &#039;calculateSpeed&#039;,
            value: function calculateSpeed(distance, time) {
                return distance / (time || 1) * 100;
            }

            /**
             * Returns an array of strings, representing the directions
             * @param  {Point} direction - the specified direction in pixel
             * @return {string[]} returns an array representing the directions as strings
             */

        }, {
            key: &#039;getSwipeDirections&#039;,
            value: function getSwipeDirections(direction) {
                return [direction.x &lt; 0 ? &quot;left&quot; : direction.x &gt; 0 ? &quot;right&quot; : &quot;none&quot;, direction.y &lt; 0 ? &quot;up&quot; : direction.y &gt; 0 ? &quot;down&quot; : &quot;none&quot;];
            }

            /**
             * Helper for setting a timeout for events
             * @param {Function} callback - function to be called
             * @param {number} timeout - time in milliseconds
             * @param {Object[]} args - array of arguments
             * @param {Boolean} holdTimeout - if true, a different variable will be used
             * @return {Interact} Returns this instance
             */

        }, {
            key: &#039;setTimeoutForEvent&#039;,
            value: function setTimeoutForEvent(callback, timeout, args, holdTimeout) {
                if (holdTimeout) {
                    this.holdTimeout = setTimeout(this.eventCallback.bind(this, callback, args), timeout);
                } else {
                    this.timeout = setTimeout(this.eventCallback.bind(this, callback, args), timeout);
                }
                return this;
            }

            /**
             * Eventhandler for handling the callbacks
             * @param  {Function} callback - function to be called
             * @param  {object[]} args - arguments for the function
             * @return {Interact} Returns this instance
             */

        }, {
            key: &#039;eventCallback&#039;,
            value: function eventCallback(callback, args) {
                if (callback &amp;&amp; typeof callback === &quot;function&quot;) {
                    callback(args);
                }
                this.lastAction = null;
                return this;
            }

            /**
             * get the relative position of clientX and clientY
             * @param  {Object} e - event object
             * @return {Point} calculated relative position
             */

        }, {
            key: &#039;getRelativePosition&#039;,
            value: function getRelativePosition(e) {
                var clientBounds = this.container.getBoundingClientRect(),
                    pos = new _Point.Point(e.clientX, e.clientY),
                    bounds = new _Point.Point(clientBounds.left, clientBounds.top);
                return pos.substract(bounds).divide(clientBounds.width, clientBounds.height);
            }

            /**
             * get the absolute position of clientX and clientY
             * @param  {Object} e - event object
             * @return {Point} calculated absolute position
             */

        }, {
            key: &#039;getAbsolutePosition&#039;,
            value: function getAbsolutePosition(point) {
                var clientBounds = this.container.getBoundingClientRect();
                return point.mult(clientBounds.width, clientBounds.height);
            }

            /**
             * get scroll direction from event
             * @param  {Object} event - event object
             * @return {string[]} an array with scroll directions
             */

        }, {
            key: &#039;getScrollDirection&#039;,
            value: function getScrollDirection(event) {
                var axis = parseInt(event.axis, 10),
                    direction = [];

                // down
                if (event.deltaY &gt; 0 || !event.deltaY &amp;&amp; event.wheelDeltaY &lt; 0 || axis === 2 &amp;&amp; event.detail &gt; 0 || Math.max(-1, Math.min(1, event.wheelDelta || -event.detail)) &lt; 0) {
                    direction.push(&quot;down&quot;);
                }
                // up
                else if (event.deltaY &lt; 0 || !event.deltaY &amp;&amp; event.wheelDeltaY &gt; 0 || axis === 2 &amp;&amp; event.detail &lt; 0 || Math.max(-1, Math.min(1, event.wheelDelta || -event.detail)) &gt; 0) {
                    direction.push(&quot;up&quot;);
                }

                // right
                if (event.deltaX &gt; 0 || !event.deltaX &amp;&amp; event.wheelDeltaX &gt; 0 || axis === 1 &amp;&amp; event.detail &gt; 0) {
                    direction.push(&quot;right&quot;);
                }

                // left
                else if (event.deltaX &lt; 0 || !event.deltaX &amp;&amp; event.wheelDeltaX &lt; 0 || axis === 1 &amp;&amp; event.detail &lt; 0) {
                    direction.push(&quot;left&quot;);
                }

                return direction;
            }

            /**
             * Get event helper, applies jQuery-event-fix too
             * @param  {Object} e - event object
             * @return {Object} new fixed and optimized event
             */

        }, {
            key: &#039;getEvent&#039;,
            value: function getEvent(e) {
                jQuery.event.fix(e);
                if (e.originalEvent.touches &amp;&amp; e.originalEvent.touches.length === 0) {
                    return e.originalEvent.changedTouches || e.originalEvent;
                }
                return e.originalEvent.touches || e.originalEvent.changedTouches || e.originalEvent;
            }
        }]);

        return Interact;
    }();
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
