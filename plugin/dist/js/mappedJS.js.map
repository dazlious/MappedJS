{"version":3,"file":"mappedJS.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 0432ecfb4f5e7ab65de4","webpack:///plugin/src/js/Main.js","webpack:///external \"jQuery\"","webpack:///plugin/src/js/Helper.js","webpack:///plugin/src/js/Events.js","webpack:///plugin/src/js/TileMap.js","webpack:///plugin/src/js/Publisher.js","webpack:///plugin/src/js/StateHandler.js","webpack:///plugin/src/js/Rectangle.js","webpack:///plugin/src/js/Point.js","webpack:///plugin/src/js/View.js","webpack:///plugin/src/js/LatLng.js","webpack:///plugin/src/js/Bounds.js","webpack:///plugin/src/js/Tile.js","webpack:///plugin/src/js/MarkerClusterer.js","webpack:///plugin/src/js/Cluster.js","webpack:///plugin/src/js/Marker.js","webpack:///plugin/src/js/DataEnrichment.js","webpack:///plugin/src/js/ToolTip.js","webpack:///external \"Handlebars\"","webpack:///plugin/src/js/Interact.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jQuery\"), require(\"Handlebars\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jQuery\", \"Handlebars\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"de\"] = factory(require(\"jQuery\"), require(\"Handlebars\"));\n\telse\n\t\troot[\"de\"] = factory(root[\"jQuery\"], root[\"Handlebars\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_18__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0432ecfb4f5e7ab65de4\n **/","import $ from 'jQuery';\nimport {Helper} from './Helper.js';\nimport {Events} from './Events.js';\nimport {TileMap} from './TileMap.js';\nimport {DataEnrichment} from './DataEnrichment.js';\nimport {Interact} from './Interact.js';\nimport {Point} from './Point.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file application initializes all instances and objects\n * @copyright Michael Duve 2016\n */\nexport class MappedJS {\n\n    /**\n     * @constructor\n     * @param  {string|Object} container=\".mjs\" - Container, either string, jQuery-object or dom-object\n     * @param  {string|Object} mapData={} - data of map tiles, can be json or path to file\n     * @param  {string|Object} markerData={} - data of markers, can be json or path to file\n     * @param  {Object} mapSettings={} - settings for map, must be json\n     * @param  {Object} events={loaded: \"mjs-loaded\"} - List of events\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    constructor({container=\".mjs\", mapData={}, markerData={}, mapSettings={}, events={loaded:\"mjs-loaded\"}} = {}) {\n        this.initializeSettings(container, events, mapSettings);\n\n        this.initializeData(mapData, (loadedMapData) => {\n            this.mapData = loadedMapData;\n            this.initializeData(markerData, (loadedMarkerData) => {\n                this.mapData = Object.assign(this.mapData, loadedMarkerData);\n                this.initializeMap();\n                this.addControls();\n                this.bindEvents();\n                this.loadingFinished();\n            });\n        });\n\n        this.momentum = null;\n        this.keyTicks = 0;\n\n        return this;\n    }\n\n    /**\n     * add controls (zoom, home) to DOM\n     */\n    addControls() {\n        if (this.mapSettings.controls) {\n            this.$controls = $(`<div class=\"control-container ${this.mapSettings.controls.theme} ${this.mapSettings.controls.position}\" />`);\n            this.$zoomIn = $(\"<div class='control zoom-in' />\");\n            this.$zoomOut = $(\"<div class='control zoom-out' />\");\n            this.$home = $(\"<div class='control home' />\");\n            this.$controls.append(this.$home).append(this.$zoomIn).append(this.$zoomOut);\n            this.$content.append(this.$controls);\n        }\n    }\n\n    /**\n     * initializes the settings and handles errors\n     * @param  {string|Object} container - Container, either string, jQuery-object or dom-object\n     * @param  {object} events - List of events\n     * @param  {object} settings - List of settings\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    initializeSettings(container, events = {}, settings = {}) {\n        this.$container = (typeof container === \"string\") ? $(container) : ((typeof container === \"object\" && container instanceof jQuery) ? container : $(container));\n        if (!(this.$container instanceof jQuery)) throw new Error(\"Container \" + container + \" not found\");\n\n        this.$container.addClass(\"mappedJS\");\n        this.$content = $(\"<div class='map-content' />\");\n        this.$container.append(this.$content);\n\n        this.mapSettings = DataEnrichment.mapSettings(settings);\n        this.events = events;\n\n        return this;\n    }\n\n    /**\n     * initializes the data, asynchronous\n     * @param  {Object} mapData - data of map tiles, can be json or path to file\n     * @param  {Helper~requestJSONCallback} cb - called, when data is received\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    initializeData(mapData, cb) {\n        if (typeof mapData === \"string\") {\n            Helper.requestJSON(mapData, (data) => {\n                cb(data);\n            });\n        } else {\n            cb((typeof mapData === \"object\") ? mapData : null);\n        }\n        return this;\n    }\n\n    /**\n     * initializes Map module\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    initializeMap() {\n        this.tileMap = new TileMap({\n            container: this.$content,\n            tilesData: this.mapData,\n            settings: this.mapSettings\n        });\n        return this;\n    }\n\n    /**\n     * get absolute position of a point\n     * @param  {Point} point - specified relative position\n     * @return {Point} absolute position to viewport\n     */\n    getAbsolutePosition(point) {\n        return point.clone.multiply(this.tileMap.view.viewport.width, this.tileMap.view.viewport.height);\n    }\n\n    /**\n     * initializes interaction\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    initializeInteractForMap() {\n        this.interact = new Interact({\n            container: this.$content,\n            autoFireHold: 300,\n            overwriteViewportSettings: true,\n            callbacks: {\n                pan: (data) => {\n                    if ($(data.target).hasClass(\"control\")) return false;\n                    const change = data.last.position.clone.substract(data.position.move);\n                    this.moveView(this.getAbsolutePosition(change).multiply(-1, -1));\n                },\n                wheel: (data) => {\n                    const factor = data.delta / 4;\n                    this.zoom(factor, this.getAbsolutePosition(data.position.start));\n                },\n                pinch: (data) => {\n                    this.zoom(data.difference * 3, this.getAbsolutePosition(data.position.move));\n                },\n                doubletap: (data) => {\n                    if (!$(data.target).hasClass(\"marker-container\")) return false;\n                    this.zoom(0.2, this.getAbsolutePosition(data.position.start));\n                },\n                flick: (data) => {\n                    const direction = new Point(data.directions[0], data.directions[1]),\n                          velocity = direction.clone.divide(data.speed).multiply(20);\n                    this.momentumAccerlation(velocity);\n\n                }\n            }\n        });\n        return this;\n    }\n\n    /**\n     * binds all events to handlers\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    bindEvents() {\n\n        this.initializeInteractForMap();\n\n        $(window).on(Events.Handling.RESIZE, this.resizeHandler.bind(this));\n\n        $(document).on(Events.Handling.KEYDOWN, this.keyPress.bind(this));\n        $(document).on(Events.Handling.KEYUP, this.keyRelease.bind(this));\n\n        const gesture = Helper.isTouch() ? Events.Handling.TOUCHSTART: Events.Handling.CLICK;\n\n        this.$zoomIn.on(gesture, this.zoomInToCenter.bind(this));\n        this.$zoomOut.on(gesture, this.zoomOutToCenter.bind(this));\n        this.$home.on(gesture, this.resetToInitialState.bind(this));\n\n        return this;\n    }\n\n    /**\n     * resets map to initial state\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    resetToInitialState() {\n        this.tileMap.reset();\n        return this;\n    }\n\n    /**\n     * zooms into center of map\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    zoomInToCenter() {\n        this.zoom(0.1, this.tileMap.view.viewport.center);\n        return this;\n    }\n\n    /**\n     * zooms out of center of map\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    zoomOutToCenter() {\n        this.zoom(-0.1, this.tileMap.view.viewport.center);\n        return this;\n    }\n\n    /**\n     * Keypress handler\n     * @param  {object} e VanillaJS-Event-Object\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    keyPress(e) {\n        switch(e.keyCode) {\n            case 38: // up\n                this.handleMovementByKeys(new Point(0, 1));\n                break;\n            case 37: // left\n                this.handleMovementByKeys(new Point(1, 0));\n                break;\n            case 39: // right\n                this.handleMovementByKeys(new Point(-1, 0));\n                break;\n            case 40: // down\n                this.handleMovementByKeys(new Point(0, -1));\n                break;\n            case 187: // plus\n            case 107: // plus numpad\n                this.zoomInToCenter();\n                break;\n            case 189: // minus\n            case 109: // minus numpad\n                this.zoomOutToCenter();\n                break;\n            case 72: // home\n                this.resetToInitialState();\n                break;\n            default:\n                break;\n        }\n        this.tileMap.view.drawIsNeeded = true;\n        return this;\n    }\n\n    /**\n     * handles the translation of the map by keypress\n     * @param  {Point} direction - x,y point where to translate to\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    handleMovementByKeys(direction) {\n        this.keyTicks++;\n        this.tileMap.view.moveView(direction.multiply(this.keyTicks));\n        return this;\n    }\n\n    keyRelease() {\n        this.keyTicks = 0;\n    }\n\n    /**\n     * momentum flicking\n     * @param  {number} velocity - speed\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    momentumAccerlation(velocity) {\n        this.maxMomentumSteps = 30;\n        this.triggerMomentum(this.maxMomentumSteps, 10, velocity.multiply(-1));\n        return this;\n    }\n\n    /**\n     * recursive momentum handler\n     * @param  {number} steps - current step (decreasing)\n     * @param  {number} timing - time for step\n     * @param  {Point} change - distance\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    triggerMomentum(steps, timing, change) {\n        this.momentum = setTimeout(() => {\n            steps--;\n            const delta = Helper.easeOutQuadratic((this.maxMomentumSteps - steps) * timing, change, change.clone.multiply(-1), timing * this.maxMomentumSteps);\n            this.moveView(delta);\n            if (steps >= 0) this.triggerMomentum(steps, timing, change);\n        }, timing);\n        return this;\n    }\n\n    /**\n     * move by delta momentum\n     * @param  {Point} delta - delta of x/y\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    moveView(delta) {\n        this.tileMap.view.moveView(delta);\n        this.tileMap.view.drawIsNeeded = true;\n        return this;\n    }\n\n    /**\n     * handles zoom by factor and position\n     * @param  {number} factor - difference in zoom scale\n     * @param  {Point} position - position to zoom to\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    zoom(factor, position) {\n        if (factor !== 0) {\n            this.tileMap.view.zoom(factor, position);\n            this.tileMap.view.drawIsNeeded = true;\n        }\n        return this;\n    }\n\n    /**\n     * handles resizing of window\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    resizeHandler() {\n        this.tileMap.resize();\n        return this;\n    }\n\n    /**\n     * called when loading and initialization is finished\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    loadingFinished() {\n        this.$container.trigger(this.events.loaded);\n        return this;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Main.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jQuery\"\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * @author Michael Duve <mduve@designmail.net>\n * @file Helper for general purposes\n * @copyright Michael Duve 2016\n * @module Helper\n */\nexport var Helper = {\n    /**\n     * request json-data from given file and calls callback on success\n     * @function\n     * @memberof module:Helper\n     * @param  {string} filename - path to file\n     * @param  {Helper~requestJSONCallback} callback - function called when data is loaded successfully\n     * @return {Helper} Helper object for chaining\n     */\n    requestJSON(filename, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === XMLHttpRequest.DONE) {\n                if (xhr.status === 200) {\n                    if (callback) callback(JSON.parse(xhr.responseText));\n                } else {\n                    throw new Error(\"The JSON submitted seems not valid\", xhr);\n                }\n            }\n        };\n        xhr.open(\"GET\", filename, true);\n        xhr.send();\n        return this;\n    },\n    /**\n     * loads an image and calls callback on success\n     * @function\n     * @memberof module:Helper\n     * @param {Helper~loadImageCallback} cb - callback-function on success\n     * @return {Helper} Helper object for chaining\n     */\n    loadImage(path, cb) {\n        const img = new Image();\n        img.onload = function() {\n            if (cb && typeof cb === \"function\") cb(img);\n        };\n        img.src = path;\n        return this;\n    },\n    /**\n     * for each helper\n     * @function\n     * @memberof module:Helper\n     * @param  {Object[]} a - array to iterate over each value\n     * @param  {Helper~forEachCallback} cb - callback for each object\n     * @return {Helper} Helper object for chaining\n     */\n    forEach(a, cb) {\n        for (const i in a) {\n            if (a[i] && typeof cb === \"function\") cb(a[i], i);\n        }\n        return this;\n    },\n    /**\n     * formula for quadratic ease out\n     * @function\n     * @memberof module:Helper\n     * @param  {number} t - current time\n     * @param  {Point} b - start value\n     * @param  {Point} c - total difference to start\n     * @param  {number} d - duration\n     * @return {number} quadratic value at specific time\n     */\n    easeOutQuadratic(t, b, c, d) {\n\t    t /= d;\n        return c.clone.multiply(-1 * t * (t-2)).add(b);\n    },\n    /**\n     * convert degree to radian\n     * @function\n     * @memberof module:Helper\n     * @param {number} degrees - specified degrees\n     * @return {number} converted radian\n     */\n    toRadians: degrees => degrees * Math.PI / 180,\n    /**\n     * checks if mouse is possible\n     * @function\n     * @memberof module:Helper\n     * @return {Boolean} if true, mouse is possible\n     */\n    isMouse: () => ('onmousedown' in window),\n\n    /**\n     * checks if touch is possible\n     * @function\n     * @memberof module:Helper\n     * @return {Boolean} if true, touch is possible\n     */\n    isTouch: () => (('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)),\n\n    /**\n     * checks if IE is used\n     * @function\n     * @memberof module:Helper\n     * @return {Boolean} if true, IE is used\n     */\n    isIE: () => ((navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)),\n\n    /**\n     * gets cross-browser scroll-event\n     * @function\n     * @memberof module:Helper\n     * @return {string} name of scroll event\n     */\n    scrollEvent: () => \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : document.onmousewheel !== undefined ? \"mousewheel\" : \"DOMMouseScroll\"\n};\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Helper.js\n **/","/**\n * @author Michael Duve <mduve@designmail.net>\n * @file Helper for naming events\n * @copyright Michael Duve 2016\n * @namespace Events\n*/\nexport var Events = {\n    /**\n     * Eventnames for ToolTip class\n     * @type {Object}\n     * @memberof Events\n     * @property {object} OPEN - when a tooltip should be openend\n     * @property {object} CLOSE - when a tooltip should be closed\n     */\n    ToolTip: {\n        OPEN: \"tooltip-open\",\n        CLOSE: \"tooltip-close\"\n    },\n    /**\n     * Eventnames for Marker class\n     * @type {Object}\n     * @memberof Events\n     * @property {object} DEACTIVATE - when a Marker should be in deactived state\n     */\n    Marker: {\n        DEACTIVATE: \"deactivate-marker\"\n    },\n    /**\n     * Eventnames for Publisher class\n     * @type {Object}\n     * @memberof Events\n     * @property {object} PUBLISH - notifies all subscribers\n     * @property {object} SUBSCRIBE - subscribes to a topic\n     * @property {object} UNSUBSCRIBE - unsubscribes from a topic\n     */\n    Publisher: {\n        PUBLISH: \"publish\",\n        SUBSCRIBE: \"subscribe\",\n        UNSUBSCRIBE: \"unsubscribe\"\n    },\n    /**\n     * Eventnames for TileMap class\n     * @type {Object}\n     * @memberof Events\n     * @property {object} IMG_DATA_NAME - notifies all subscribers\n     * @property {object} MARKER_DATA_NAME - subscribes to a topic\n     * @property {object} NEXT_LEVEL - next level of view\n     * @property {object} PREVIOUS_LEVEL - previous level of view\n     * @property {object} RESIZE - resize of view needed\n     */\n    TileMap: {\n        IMG_DATA_NAME: \"img_data\",\n        MARKER_DATA_NAME: \"marker\",\n        NEXT_LEVEL: \"next-level\",\n        PREVIOUS_LEVEL: \"previous-level\",\n        RESIZE: \"resize\"\n    },\n    /**\n     * Eventnames for Handling in all classes\n     * @type {Object}\n     * @memberof Events\n     * @property {object} RESIZE - resize of window happened needed\n     * @property {object} CLICK - click occured\n     * @property {object} TOUCHSTART - Touch started\n     * @property {object} KEYDOWN - key pressed\n     * @property {object} KEYUP - key released\n\n     */\n    Handling: {\n        RESIZE: \"resize orientationchange\",\n        CLICK: \"click\",\n        TOUCHSTART: \"touchstart\",\n        KEYDOWN: \"keydown\",\n        KEYUP: \"keyup\"\n    },\n    View: {\n        DRAW: \"draw\"\n    }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Events.js\n **/","import $ from 'jQuery';\nimport {Helper} from './Helper.js';\nimport {Events} from './Events.js';\nimport {Publisher} from './Publisher.js';\nimport {StateHandler} from './StateHandler.js';\nimport {Rectangle} from './Rectangle.js';\nimport {View} from './View.js';\nimport {Marker} from './Marker.js';\nimport {DataEnrichment} from './DataEnrichment.js';\nimport {ToolTip} from './ToolTip.js';\nimport {MarkerClusterer} from './MarkerClusterer.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file Represents a map with its different levels of zooms and markers\n * @copyright Michael Duve 2016\n */\nexport class TileMap {\n\n    /**\n     * Returns left offset of container\n     * @return {number} - left offset of container\n     */\n    get left() {\n        return this.$container.position().left - this.$container.offset().left;\n    }\n\n    /**\n     * Returns top offset of container\n     * @return {number} - top offset of container\n     */\n    get top() {\n        return this.$container.position().top - this.$container.offset().top;\n    }\n\n    /**\n     * Returns width of container\n     * @return {number} - width of container\n     */\n    get width() {\n        return this.$container.innerWidth();\n    }\n\n    /**\n     * Returns height of container\n     * @return {number} - height of container\n     */\n    get height() {\n        return this.$container.innerHeight();\n    }\n\n    /**\n     * gets data of current zoom level\n     * @return {Object} data for current level as json\n     */\n    get currentLevelData() {\n        return this.levelHandler.current.value;\n    }\n\n    /**\n     * @constructor\n     * @param  {Object} container = null - jQuery-object holding the container\n     * @param  {Object} tilesData={} - json object representing data of TileMap\n     * @param  {Object} settings={} - json object representing settings of TileMap\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    constructor({container = null, tilesData = {}, settings = {}}) {\n        if (!container) throw Error(\"You must define a container to initialize a TileMap\");\n        this.$container = container;\n\n        this.imgData = tilesData[Events.TileMap.IMG_DATA_NAME];\n        this.markerData = tilesData[Events.TileMap.MARKER_DATA_NAME];\n        this.settings = settings;\n\n        this.levels = [];\n\n        Helper.forEach(this.imgData, (element, i) => {\n            const currentLevel = {\n                value: element,\n                description: i\n            };\n            this.levels.push(currentLevel);\n        });\n\n        this.levelHandler = new StateHandler(this.levels);\n        this.levelHandler.changeTo(this.settings.level);\n        this.eventManager = new Publisher();\n\n        this.initial = {\n            bounds: settings.bounds,\n            center: settings.center,\n            level: settings.level,\n            zoom: settings.zoom\n        };\n\n        return this.appendMarkerContainerToDom().initialize(settings.bounds, settings.center, this.currentLevelData);\n    }\n\n    /**\n     * initializes the TileMap\n     * @param {Bounds} bounds - specified boundaries\n     * @param {LatLng} center - specified center\n     * @param {object} data - specified data\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    initialize(bounds, center, data) {\n        this.initializeCanvas()\n            .bindEvents();\n        this.view = this.createViewFromData(bounds, center, data, this.settings.zoom);\n        this.initializeMarkers(this.markerData);\n        return this.resizeCanvas();\n    }\n\n    /**\n     * resets view to initial state\n     */\n    reset() {\n        if (this.levelHandler.hasPrevious()) {\n            this.levelHandler.changeTo(0);\n            this.view = this.createViewFromData(this.initial.bounds, this.initial.center, this.currentLevelData, this.initial.zoom);\n        } else this.view.reset();\n    }\n\n    /**\n     * creates a View from specified parameters\n     * @param  {Bounds} bounds - specified boundaries\n     * @param  {LatLng} center - specified center\n     * @param  {object} data - specified data\n     * @param  {number} zoom - initial zoom level\n     * @return {View} created View\n     */\n    createViewFromData(bounds, center, data, zoom) {\n        return new View({\n            viewport: new Rectangle(this.left, this.top, this.width, this.height),\n            currentView: new Rectangle(0, 0, data.dimensions.width, data.dimensions.height),\n            bounds: bounds,\n            center: center,\n            initialCenter: this.initial.center,\n            data: data,\n            maxZoom: (data.zoom) ? data.zoom.max : 1,\n            currentZoom: zoom,\n            minZoom: (data.zoom) ? data.zoom.min : 1,\n            $container: this.$container,\n            $markerContainer: this.$markerContainer,\n            context: this.canvasContext,\n            limitToBounds: this.settings.limitToBounds\n        });\n    }\n\n    /**\n     * enrich marker data\n     * @param  {Object} markerData - data of markers\n     * @return {Object} enriched marker data\n     */\n    enrichMarkerData(markerData) {\n        return DataEnrichment.marker(markerData);\n    }\n\n    /**\n     * initializes all markers\n     * @param  {Object} markerData - data of all markers\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    initializeMarkers(markerData) {\n        if (markerData) {\n            let markers = [];\n            markerData = this.enrichMarkerData(markerData);\n            Helper.forEach(markerData, (currentData) => {\n                markers.push(new Marker(currentData, this.view));\n            });\n            markers = markers.sort((a, b) => ((b.latlng.lat - a.latlng.lat !== 0) ? b.latlng.lat - a.latlng.lat : b.latlng.lat - a.latlng.lat));\n            Helper.forEach(markers, (marker, i) => {\n                marker.$icon.css(\"z-index\", i);\n            });\n\n            if (markers.length !== 0) this.createTooltipContainer();\n\n            this.markerClusterer = new MarkerClusterer({\n                markers: markers,\n                view: this.view,\n                $container: this.$markerContainer\n            });\n        }\n        return this;\n    }\n\n    /**\n     * append marker container to DOM\nÂ´     * @return {TileMap} instance of TileMap for chaining\n     */\n    appendMarkerContainerToDom() {\n        this.$markerContainer = $(\"<div class='marker-container' />\");\n        this.$container.append(this.$markerContainer);\n        return this;\n    }\n\n    /**\n     * creates an instance of ToolTip\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    createTooltipContainer() {\n        this.tooltip = new ToolTip({\n            container: $(this.$container.parent()),\n            templates: {\n                image: \"../../src/hbs/image.hbs\"\n            }\n        });\n        return this;\n    }\n\n    /**\n     * bind all events\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    bindEvents() {\n\n        this.eventManager.subscribe(Events.TileMap.RESIZE, () => { this.resize(); });\n\n        this.eventManager.subscribe(Events.TileMap.NEXT_LEVEL, (argument_array) => {\n            const center = argument_array[0],\n                  bounds = argument_array[1],\n                  lastLevel = this.levelHandler.current.description;\n\n            this.levelHandler.next();\n\n            if (lastLevel !== this.levelHandler.current.description) {\n                this.view = this.createViewFromData(bounds, center.multiply(-1), this.currentLevelData, this.currentLevelData.zoom.min + 0.0000001);\n                if (this.levelHandler.hasNext()) {\n                    if (this.markerClusterer) this.markerClusterer.view = this.view; this.markerClusterer.clusterize();\n                } else {\n                    if (this.markerClusterer) this.markerClusterer.deleteAllClusters();\n                }\n            }\n        });\n\n        this.eventManager.subscribe(Events.TileMap.PREVIOUS_LEVEL, (argument_array) => {\n            const center = argument_array[0],\n                  bounds = argument_array[1],\n                  lastLevel = this.levelHandler.current.description;\n\n            this.levelHandler.previous();\n\n            if (lastLevel !== this.levelHandler.current.description) {\n                this.view = this.createViewFromData(bounds, center.multiply(-1), this.currentLevelData, this.currentLevelData.zoom.max - 0.0000001);\n                if (this.markerClusterer) this.markerClusterer.view = this.view; this.markerClusterer.clusterize();\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * initializes the canvas, adds to DOM\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    initializeCanvas() {\n        this.$canvas = $(\"<canvas class='mjs-canvas' />\");\n        this.canvas = this.$canvas[0];\n        this.$container.append(this.$canvas);\n        this.canvasContext = this.canvas.getContext(\"2d\");\n        return this;\n    }\n\n    /**\n     * complete clear and draw of all visible tiles\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    redraw() {\n        this.view.drawIsNeeded = true;\n        return this;\n    }\n\n    /**\n     * Handles resizing of TileMap\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    resize() {\n        return this.resizeCanvas()\n                   .resizeView()\n                   .redraw();\n    }\n\n    /**\n     * resizes the canvas sizes\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    resizeCanvas() {\n        this.canvasContext.canvas.width = this.width;\n        this.canvasContext.canvas.height = this.height;\n        return this;\n    }\n\n    /**\n     * Handles resizing of view\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    resizeView() {\n        const oldViewport = this.view.viewport.clone;\n        this.view.viewport.size(this.left, this.top, this.width, this.height);\n        const delta = this.view.viewport.center.substract(oldViewport.center);\n        this.view.currentView.translate(delta.x, delta.y);\n        return this;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/TileMap.js\n **/","import {Events} from './Events.js';\n\n/**\n * singleton instance\n * @type {Publisher}\n */\nlet instance = null;\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file Publish/Subscribe pattern\n * @copyright Michael Duve 2016\n */\nexport class Publisher {\n\n    /**\n     * @constructor\n     * @return {Publisher} singleton instance of Publisher for chaining\n     */\n    constructor() {\n        if(!instance) {\n            this.subscribers = {};\n            instance = this;\n        }\n        return instance;\n    }\n\n    /**\n     * subscribe to a topic\n     * @param  {string} type=\"any\" - a topic\n     * @param  {Function} fn=function(){} - a function to callback\n     * @return {Publisher} instance of Publisher for chaining\n     */\n    subscribe(type = \"any\", fn = function() {}) {\n        if (!this.subscribers[type]) this.subscribers[type] = [];\n        this.subscribers[type].push(fn);\n        return this;\n    }\n\n    /**\n     * unsubscribe from a topic\n     * @param  {string} type=\"any\" - a topic\n     * @param  {Function} fn=function(){} - a function to callback\n     * @return {Publisher} instance of Publisher for chaining\n     */\n    unsubscribe(type = \"any\", fn = function() {}) {\n        return this.handle(Events.Publisher.UNSUBSCRIBE, type, fn);\n    }\n\n    /**\n     * publish to a topic\n     * @param  {string} type=\"any\" - a topic\n     * @param  {Function} arg=[] - list of parameters\n     * @return {Publisher} instance of Publisher for chaining\n     */\n    publish(type = \"any\", arg = []) {\n        return this.handle(Events.Publisher.PUBLISH, type, arg);\n    }\n\n    /**\n     * handle subscribe to a topic\n     * @param  {string} action - eventname\n     * @param  {string} type=\"any\" - a topic\n     * @param  {Object} a function to callback or arguments\n     * @return {Publisher} instance of Publisher for chaining\n     */\n    handle(action, type, data) {\n        const subs = (this.subscribers[type]) ? this.subscribers[type]: [];\n        for (const [i, fn] of subs.entries()) {\n            if (action === Events.Publisher.PUBLISH) {\n                fn(data);\n            } else {\n                if (fn === data) subs.splice(i,1);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * destroys singleton instance\n     */\n    destroy() {\n        instance = null;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Publisher.js\n **/","/**\n * @author Michael Duve <mduve@designmail.net>\n * @file State pattern\n * @copyright Michael Duve 2016\n */\nexport class StateHandler {\n\n    /**\n     * get current state\n     * @return {Object} current state from STATES-array\n     */\n    get current() {\n        return this.states[this.i];\n    }\n\n    /**\n     * get number of states\n     * @return {number} number of states\n     */\n    get length() {\n        return this.states.length;\n    }\n\n    /**\n     * @constructor\n     * @param  {Array} states_array=[{value: 0, description: 'Default'}] - [description]\n     * @return {StateHandler} instance of StateHandler for chaining\n     */\n    constructor(states_array=[{value: 0, description: 'Default'}]) {\n        this.states = states_array;\n        this.i = 0;\n        this.lastState = this.current;\n        return this;\n    }\n\n    /**\n     * get the next element\n     * @return {StateHandler} instance of StateHandler for chaining\n     */\n    next() {\n        this.lastState = this.current;\n        if (this.hasNext()) this.i++;\n        return this;\n    }\n\n    /**\n     * get the previous element\n     * @return {StateHandler} instance of StateHandler for chaining\n     */\n    previous() {\n        this.lastState = this.current;\n        if (this.hasPrevious()) this.i--;\n        return this;\n    }\n\n    /**\n     * change the state to specified state\n     * @param {number} state - index of state in array\n     * @return {StateHandler} instance of StateHandler for chaining\n     */\n    changeTo(state) {\n        if (state >= 0 && state < this.length) this.i = state;\n        return this;\n    }\n\n    /**\n     * change the state to specified value of specified property\n     * @param {object} prop - specified property to be changed\n     * @param {object} value - specified value that should be changed to\n     * @return {StateHandler} instance of StateHandler for chaining\n     */\n    changeToValue(prop, value) {\n        for (const [i, element] of this.states) {\n            if (value === element[prop]) {\n                this.i = i;\n                break;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * checks if there is a next element\n     * @return {Boolean} wheter there is a next state or not\n     */\n    hasNext() {\n        return this.i < this.length-1;\n    }\n\n    /**\n     * checks if there is a previous element\n     * @return {Boolean} wheter there is a previous state or not\n     */\n    hasPrevious() {\n        return this.i > 0;\n    }\n\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/StateHandler.js\n **/","import {Point} from './Point.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents a rectangle with a point as position, width and height\n * @extends Point\n * @copyright Michael Duve 2016\n */\nexport class Rectangle extends Point {\n\n    /**\n     * get center-position of rectangle\n     * @return {Point} center point\n     */\n    get center() {\n        return new Point(this.x + (this.width / 2), this.y + (this.height / 2));\n    }\n\n    /**\n     * get top-left-position of rectangle\n     * @return {Point} top-left point\n     */\n    get topLeft() {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * get top-right-position of rectangle\n     * @return {Point} top-right point\n     */\n    get topRight() {\n        return new Point(this.x + this.width, this.y);\n    }\n\n    /**\n     * get bottom-left-position of rectangle\n     * @return {Point} bottom-left point\n     */\n    get bottomLeft() {\n        return new Point(this.x, this.y + this.height);\n    }\n\n    /**\n     * get bottom-right-position of rectangle\n     * @return {Point} bottom-right point\n     */\n    get bottomRight() {\n        return new Point(this.x + this.width, this.y + this.height);\n    }\n\n    /**\n     * Returns right position of Rectangle\n     * @return {number} right position\n     */\n    get right() {\n        return this.x + this.width;\n    }\n\n    /**\n     * Returns left position of Rectangle\n     * @return {number} left position\n     */\n    get left() {\n        return this.x;\n    }\n\n    /**\n     * Returns top position of Rectangle\n     * @return {number} top position\n     */\n    get top() {\n        return this.y;\n    }\n\n    /**\n     * Returns bottom position of Rectangle\n     * @return {number} bottom position\n     */\n    get bottom() {\n        return this.y + this.height;\n    }\n\n    /**\n     * clones a rectangle\n     * @return {Rectangle} duplicated rectangle\n     */\n    get clone() {\n        return Rectangle.createFromRectangle(this);\n    }\n\n    /**\n     * @constructor\n     * @param  {number} x=0 - x-position of specified rectangle\n     * @param  {number} y=0 - y-position of specified rectangle\n     * @param  {number} width=0 - width of specified rectangle\n     * @param  {number} height=0 - height of specified rectangle\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    constructor(x=0, y=0, width=0, height=0) {\n        super(x, y);\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n\n    /**\n     * Checks whether Rectangle intersects with specified Rectangle\n     * @param  {Rectangle} rect = new Rectangle() - the specified rectangle to check against\n     * @return {Boolean} true if containment is entirely\n     */\n    intersects(rect = new Rectangle()) {\n        return !(rect.left > this.right || rect.right < this.left || rect.top > this.bottom || rect.bottom < this.top);\n    }\n\n    /**\n     * Checks whether Rectangle entirely contains the Rectangle or Point\n     * @param  {Rectangle|Point} rectOrPoint - the specified point or rectangle to check against\n     * @return {Boolean} true if containment is entirely\n     */\n    contains(rectOrPoint) {\n        return (rectOrPoint instanceof Rectangle) ? this.containsRect(rectOrPoint) : (rectOrPoint instanceof Point) ? this.containsPoint(rectOrPoint) : false;\n    }\n\n    extend(rect) {\n        const left = Math.min(this.left, rect.left);\n        const right = Math.max(this.right, rect.right);\n        const top = Math.min(this.top, rect.top);\n        const bottom = Math.max(this.bottom, rect.bottom);\n        this.size(left, top, right - left, bottom - top);\n        return this;\n    }\n\n    /**\n     * Sets the center of this Rectangle to specified point\n     * @param  {Point} point = new Point() - specified point to set center of rectangle to\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    setCenter(point = new Point()) {\n        const difference = point.substract(this.center);\n        this.translate(difference.x, difference.y);\n        return this;\n    }\n\n    /**\n     * Sets the x-center of this Rectangle to specified x\n     * @param  {number} x = 0 - specified x coordinate to set x center of rectangle to\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    setCenterX(x = 0) {\n        const difference = x - this.center.x;\n        this.translate(difference, 0);\n        return this;\n    }\n\n    /**\n     * Sets the y-center of this Rectangle to specified y\n     * @param  {number} y = 0 - specified y coordinate to set y center of rectangle to\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    setCenterY(y = 0) {\n        const difference = y - this.center.y;\n        this.translate(0, difference);\n        return this;\n    }\n\n\n    /**\n     * Checks whether Rectangle entirely contains the Point\n     * @param  {Point} point = new Point() - the specified point to check against\n     * @return {Boolean} true if containment is entirely\n     */\n    containsPoint(point = new Point()) {\n        return (point instanceof Point) ? point.x >= this.left && point.y >= this.top && point.x <= this.right && point.y <= this.bottom : false;\n    }\n\n    /**\n     * Checks whether Rectangle entirely contains the Rectangle\n     * @param  {Rectangle} rect = new Rectangle() - the specified rectangle to check against\n     * @return {Boolean} true if containment is entirely\n     */\n    containsRect(rect = new Rectangle()) {\n        return (rect instanceof Rectangle) ? rect.left >= this.left && rect.top >= this.top && rect.right <= this.right && rect.bottom <= this.bottom : false;\n    }\n\n    /**\n     * distorts rectangle by factor\n     * @param  {number} factor = 1 - the specified factor of distortion\n     * @return {Rectangle} a distorted Rectangle\n     */\n    getDistortedRect(factor = 1) {\n        return new Rectangle(this.x, this.y, this.width, this.height).scaleX(factor);\n    }\n\n    /**\n     * redistorts rectangle by factor\n     * @param  {number} factor = 1- the specified factor of distortion\n     * @return {Rectangle} an undistorted Rectangle\n     */\n    getNormalRect(factor = 1) {\n        return new Rectangle(this.x, this.y, this.width, this.height).scaleX(1/factor);\n    }\n\n    /**\n     * scale x and width of rectangle\n     * @param  {number} x = 1 - factor to be applied to scale\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    scaleX(x = 1) {\n        this.x *= x;\n        this.width *= x;\n        return this;\n    }\n\n    /**\n     * scale y and height of rectangle\n     * @param  {number} y = 1- factor to be applied to scale\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    scaleY(y = 1) {\n        this.y *= y;\n        this.height *= y;\n        return this;\n    }\n\n    /**\n     * scale x and y for width and height of rectangle\n     * @param  {number} x = 1 - factor to be applied to scale\n     * @param  {number} y = x - factor to be applied to scale\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    scale(x = 1, y = x) {\n        this.scaleX(x);\n        this.scaleY(y);\n        return this;\n    }\n\n    /**\n     * moves a rectangle by specified coords\n     * @param  {number} x = 0 - specified x to be added to x position\n     * @param  {number} y = x - specified y to be added to y position\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    translate(x = 0, y = x) {\n        super.translate(x, y);\n        return this;\n    }\n\n    /**\n     * transforms a rectangle by specified coords\n     * @param  {number} x = 0 - specified x to be added to x position\n     * @param  {number} y = x - specified y to be added to y position\n     * @param  {number} width = 0 - specified width to be added to this width\n     * @param  {number} height = 0 - specified height to be added to this height\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    transform(x = 0, y = x, width = 0, height = 0) {\n        this.translate(x, y);\n        this.width += width;\n        this.height += height;\n        return this;\n    }\n\n    /**\n     * changes the position a rectangle by specified coords\n     * @param  {number} x = 0 - the new x position\n     * @param  {number} y = 0 - he new y position\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    position(x = 0, y = 0) {\n        super.position(x, y);\n        return this;\n    }\n\n    /**\n     * changes the size of a rectangle by specified params\n     * @param  {number} x = 0- the new x position\n     * @param  {number} y = x - the new y position\n     * @param  {number} width = 0 - the new width\n     * @param  {number} height = 0 - the new width\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    size(x = 0, y = x, width = 0, height = 0) {\n        this.position(x, y);\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n\n    /**\n     * changes the size of a rectangle by specified params\n     * @param  {number} width = 0 - the new width\n     * @param  {number} height = width - the new width\n     * @return {Rectangle} instance of Rectangle for chaining\n     */\n    setSize(width = 0, height = width) {\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n\n    /**\n     * check if rectangles are equal\n     * @param  {Rectangle} rectangle - the specified rectangle to check against this\n     * @return {Boolean} is true, if x, y, width and height are the same\n     */\n    equals(rectangle) {\n        return (rectangle instanceof Rectangle) ? this.x === rectangle.x && this.y === rectangle.y && this.width === rectangle.width && this.height === rectangle.height : false;\n    }\n\n}\n\n/**\n * Creates a Rectangle from specified Rectangle\n * @param  {Rectangle} rect - specified Rectangle\n * @return {Rectangle} a copy of specified rectangle\n */\nRectangle.createFromRectangle = (rect) => new Rectangle(rect.x, rect.y, rect.width, rect.height);\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Rectangle.js\n **/","/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents a point with x and y value\n * @copyright Michael Duve 2016\n */\nexport class Point {\n\n    /**\n     * length of a point\n     * @return {number} length of a point\n     */\n    get length() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n    }\n\n    /**\n     * gets a clone of this point\n     * @return {Point} new instance equals this point\n     */\n    get clone() {\n        return Point.createFromPoint(this);\n    }\n\n    /**\n     * gets absolute Point\n     * @return {Point} returns Point with absolute values\n     */\n    get abs() {\n        return new Point(Math.abs(this.x), Math.abs(this.y));\n    }\n\n    /**\n     * @constructor\n     * @param  {number} x = 0 - representation of x coordinate\n     * @param  {number} y = 0 - representation of y coordinate\n     * @return {Point} instance of Point for chaining\n     */\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n\n    /**\n     * substracts 2 points\n     * @param  {Point} point = new Point() - the point to substract from this\n     * @return {Point} instance of Point for chaining\n     */\n    substract(point = new Point()) {\n        this.x -= point.x;\n        this.y -= point.y;\n        return this;\n    }\n\n    /**\n     * adds 2 points\n     * @param  {Point} point = new Point() - the point to add to this\n     * @return {Point} instance of Point for chaining\n     */\n    add(point = new Point()) {\n        this.x += point.x;\n        this.y += point.y;\n        return this;\n    }\n\n    /**\n     * multiplicates a point with a given x and y\n     * @param  {number} x = 1 - factor to multiplicate x with\n     * @param  {number} y = x - factor to multiplicate y with\n     * @return {Point} instance of Point for chaining\n     */\n    multiply(x = 1, y = x) {\n        this.x *= x;\n        this.y *= y;\n        return this;\n    }\n\n    /**\n     * divide a point with a given x and y\n     * @param  {number} x = 1 - factor to divide x with\n     * @param  {number} y = x - factor to divide y with\n     * @return {Point} instance of Point for chaining\n     */\n    divide(x = 1, y = x) {\n        this.x /= x;\n        this.y /= y;\n        return this;\n    }\n\n    /**\n     * check if points are equal\n     * @param  {Point} point - the point to check against this\n     * @return {Boolean} is true, if x and y are the same\n     */\n    equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n\n    /**\n     * Returns the distance from this Point to a specified Point\n     * @param  {Point} point = new Point() - the specified point to be measured against this Point\n     * @return {Point} the distance between this Point and specified point\n     */\n    distance(point = new Point()) {\n        return this.clone.substract(point).length;\n    }\n\n    /**\n     * translates a point by x and y\n     * @param  {number} x = 0 - value to move x\n     * @param  {number} y = x - value to move y\n     * @return {Point} instance of Point for chaining\n     */\n    translate(x = 0, y = x) {\n        this.x += x;\n        this.y += y;\n        return this;\n    }\n\n    /**\n     * positions a point by x and y\n     * @param  {number} x = 0 - value to position x\n     * @param  {number} y = x - value to position y\n     * @return {Point} instance of Point for chaining\n     */\n    position(x = 0, y = x) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n\n    /**\n     * translates a Point to an array\n     * @return {Array} Returns Point as Array(x, y)\n     */\n    toArray() {\n        return [this.x, this.y];\n    }\n\n}\n\n/**\n * Creates a Point from specified point\n * @param  {Point} point - specified point\n * @return {Point} the point specified\n */\nPoint.createFromPoint = (point) => new Point(point.x, point.y);\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Point.js\n **/","import {Helper} from './Helper.js';\nimport {Events} from './Events.js';\nimport {Point} from './Point.js';\nimport {LatLng} from './LatLng.js';\nimport {Bounds} from './Bounds.js';\nimport {Rectangle} from './Rectangle.js';\nimport {Tile} from './Tile.js';\nimport {Publisher} from './Publisher.js';\nimport {MarkerClusterer} from './MarkerClusterer.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents a level of zoom\n * @copyright Michael Duve 2016\n */\nexport class View {\n\n    /**\n     * Returns current distortionFactor\n     * @return {number} returns current distortionFactor of latitude\n     */\n    get distortionFactor() {\n        return this.getDistortionFactorForLatitude(this.center);\n    }\n\n    /**\n     * Returns the current distorted viewport\n     */\n    get offsetToCenter() {\n        return (this.viewport.width - this.viewport.width * this.distortionFactor) / 2;\n    }\n\n    /**\n     * get all visible tiles\n     * @return {array} all tiles that are currently visible\n     */\n    get visibleTiles() {\n        return this.tiles.filter((t) => {\n            const newTile = t.clone.scale(this.zoomFactor, this.zoomFactor).getDistortedRect(this.distortionFactor).translate(this.currentView.x * this.distortionFactor + this.offsetToCenter, this.currentView.y);\n            return this.viewport.intersects(newTile);\n        });\n    }\n\n    /**\n     * how many pixels per lat and lng\n     * @return {Point} pixels per lat/lng\n     */\n    get pixelPerLatLng() {\n        return new Point(this.currentView.width / this.bounds.width, this.currentView.height / this.bounds.height);\n    }\n\n    /**\n     * @constructor\n     * @param  {Rectangle} viewport = new Rectangle() - current representation of viewport\n     * @param  {Rectangle} currentView = new Rectangle() - current representation of map\n     * @param  {Bounds} bounds = new Bounds() - current bounds of map\n     * @param  {LatLng} center = new LatLng() - current center of map\n     * @param  {LatLng} initialCenter = new LatLng() - initial center of view\n     * @param  {Object} data = {} - tile data of current map\n     * @param  {Object} $container = null - parent container for markers\n     * @param  {Object} context = null - canvas context for drawing\n     * @param  {number} maxZoom = 1.5 - maximal zoom of view\n     * @param  {number} currentZoom = 1 - initial zoom of view\n     * @param  {number} minZoom = 0.8 - minimal zoom of view\n     * @param  {object} $container = null - jQuery-selector of container class\n     * @param  {number} limitToBounds - where to limit panning\n     * @return {View} instance of View for chaining\n     */\n    constructor({\n        viewport = new Rectangle(),\n        currentView = new Rectangle(),\n        bounds = new Bounds(),\n        center = new LatLng(),\n        initialCenter = new LatLng(),\n        data = {},\n        $container = null,\n        context = null,\n        maxZoom = 1.5,\n        currentZoom = 1,\n        minZoom = 0.8,\n        $markerContainer = null,\n        limitToBounds\n    }) {\n\n        this.$markerContainer = $markerContainer;\n        this.currentView = currentView;\n        this.originalMapView = currentView.clone;\n        this.viewport = viewport;\n        this.bounds = bounds;\n        this.center = center;\n        this.zoomFactor = currentZoom;\n        this.maxZoom = maxZoom;\n        this.minZoom = minZoom;\n        this.origin = new Point();\n        this.eventManager = new Publisher();\n        this.limitToBounds = limitToBounds || bounds;\n\n        const newCenter = this.viewport.center.substract(this.convertLatLngToPoint(center));\n        this.currentView.position(newCenter.x, newCenter.y);\n\n        this.tiles = [];\n        this.data = data;\n        this.context = context;\n\n        this.initial = {\n            position: initialCenter,\n            zoom: this.zoomFactor\n        };\n\n        this.drawIsNeeded = true;\n\n        this.initializeTiles().loadThumb();\n\n        this.zoom(0, this.viewport.center);\n\n        return this;\n    }\n\n    /**\n     * resets current View to its initial position\n     */\n    reset() {\n        this.setLatLngToPosition(this.initial.position, this.viewport.center);\n        const delta = this.initial.zoom - this.zoomFactor;\n        this.zoom(delta, this.viewport.center);\n    }\n\n    /**\n     * main draw call\n     */\n    mainLoop() {\n        if (this.drawIsNeeded) {\n            this.context.clearRect(0, 0, this.viewport.width, this.viewport.height);\n            this.checkBoundaries();\n            this.draw();\n            this.drawIsNeeded = false;\n        }\n        window.requestAnimFrame(() => this.mainLoop());\n    }\n\n    checkBoundaries() {\n        const nw = this.convertLatLngToPoint(this.limitToBounds.nw),\n              se = this.convertLatLngToPoint(this.limitToBounds.se),\n              limit = new Rectangle(nw.x + this.currentView.x, nw.y + this.currentView.y, se.x - nw.x, se.y - nw.y);\n\n        const offset = new Point();\n        const equalizedMap = limit.getDistortedRect(this.distortionFactor).translate(this.offsetToCenter, 0);\n        if (!equalizedMap.containsRect(this.viewport)) {\n            if (equalizedMap.width >= this.viewport.width) {\n                if (equalizedMap.left - this.viewport.left > 0) {\n                    offset.x -= (equalizedMap.left - this.viewport.left);\n                }\n                if (equalizedMap.right - this.viewport.right < 0) {\n                    offset.x -= (equalizedMap.right - this.viewport.right);\n                }\n            } else {\n                this.currentView.setCenterX(this.viewport.center.x);\n                offset.x = 0;\n            }\n\n            if (equalizedMap.height >= this.viewport.height) {\n                if (equalizedMap.top - this.viewport.top > 0) {\n                    offset.y -= (equalizedMap.top - this.viewport.top);\n                }\n                if (equalizedMap.bottom - this.viewport.bottom < 0) {\n                    offset.y -= (equalizedMap.bottom - this.viewport.bottom);\n                }\n            } else {\n                this.currentView.setCenterY(this.viewport.center.y);\n                offset.y = 0;\n            }\n        }\n        offset.multiply(1/this.distortionFactor, 1);\n        this.currentView.translate(offset.x, offset.y);\n    }\n\n    /**\n     * loads thumbnail of view\n     * @return {View} instance of View for chaining\n     */\n    loadThumb() {\n        Helper.loadImage(this.data.thumb, (img) => {\n            this.thumb = img;\n            window.requestAnimFrame(this.mainLoop.bind(this));\n        });\n        return this;\n    }\n\n    /**\n     * converts a Point to LatLng in view\n     * @param  {Point} point - specified point to be converted\n     * @return {LatLng} presentation of point in lat-lng system\n     */\n    convertPointToLatLng(point) {\n        point.divide(this.pixelPerLatLng.x, this.pixelPerLatLng.y);\n        return new LatLng(this.bounds.nw.lat - point.y, point.x + this.bounds.nw.lng).multiply(-1);\n    }\n\n    /**\n     * set specified lat/lng to position x/y\n     * @param {LatLng} latlng - specified latlng to be set Point to\n     * @param {Point} position - specified position to set LatLng to\n     * @return {View} instance of View for chaining\n     */\n    setLatLngToPosition(latlng, position) {\n        const currentPosition = this.currentView.topLeft.substract(position).multiply(-1),\n              diff = currentPosition.substract(this.convertLatLngToPoint(latlng));\n\n        this.currentView.translate(0, diff.y);\n        this.calculateNewCenter();\n        this.currentView.translate(diff.x + this.getDeltaXToCenter(position), 0);\n        return this;\n    }\n\n    /**\n     * converts a LatLng to Point in view\n     * @param  {LatLng} latlng - specified latlng to be converted\n     * @return {Point} presentation of point in pixel system\n     */\n    convertLatLngToPoint(latlng) {\n        const relativePosition = this.bounds.nw.clone.substract(latlng);\n        relativePosition.multiply(this.pixelPerLatLng.y, this.pixelPerLatLng.x);\n        return new Point(relativePosition.lng, relativePosition.lat).abs;\n    }\n\n    /**\n     * receive relative Position to center of viewport\n     * @param  {Point} pos - specified position\n     * @return {number} delta of point to center of viewport\n     */\n    getDeltaXToCenter(pos) {\n        const diffToCenter = pos.clone.substract(this.viewport.center),\n              distanceToCenter = (diffToCenter.x / this.viewport.center.x),\n              delta = distanceToCenter * this.offsetToCenter;\n        return delta / this.distortionFactor;\n    }\n\n    /**\n     * zooming handler\n     * @param  {number} factor - increase/decrease factor\n     * @param  {Point} pos - Position to zoom to\n     * @return {View} instance of View for chaining\n     */\n    zoom(factor, pos) {\n        this.zoomFactor = Math.max(Math.min(this.zoomFactor + factor, this.maxZoom), this.minZoom);\n\n        const mapPosition = this.currentView.topLeft.substract(pos).multiply(-1);\n        mapPosition.x += this.getDeltaXToCenter(pos);\n        const latlngPosition = this.convertPointToLatLng(mapPosition).multiply(-1);\n\n        const newSize = this.originalMapView.clone.scale(this.zoomFactor);\n        this.currentView.setSize(newSize.width, newSize.height);\n\n        this.setLatLngToPosition(latlngPosition, pos);\n        this.moveView(new Point());\n\n        if (this.zoomFactor >= this.maxZoom) {\n            this.eventManager.publish(Events.TileMap.NEXT_LEVEL, [this.center, this.bounds]);\n        } else if (this.zoomFactor <= this.minZoom) {\n            this.eventManager.publish(Events.TileMap.PREVIOUS_LEVEL, [this.center, this.bounds]);\n        }\n        this.drawIsNeeded = true;\n\n        return this;\n    }\n\n    /**\n     * get distortion factor for specified latitude\n     * @param  {LatLng} latlng - lat/lng position\n     * @return {number} distortion factor\n     */\n    getDistortionFactorForLatitude(latlng) {\n         return (Math.cos(Helper.toRadians(latlng.lat)));\n    }\n\n    /**\n     * update center position of view\n     * @return {View} instance of View for chaining\n     */\n    calculateNewCenter() {\n        const newCenter = this.viewport.center.substract(this.currentView.topLeft);\n        this.center = this.convertPointToLatLng(newCenter);\n        return this;\n    }\n\n    /**\n     * moves the view's current position by pos\n     * @param  {Point} pos - specified additional offset\n     * @return {View} instance of View for chaining\n     */\n    moveView(pos) {\n        this.currentView.translate(0, pos.y);\n        this.calculateNewCenter();\n        this.currentView.translate(pos.x * (1/this.distortionFactor), 0);\n        return this;\n    }\n\n    /**\n     * Handles draw of visible elements\n     * @return {View} instance of View for chaining\n     */\n    draw() {\n        return this.drawThumbnail()\n            .drawVisibleTiles()\n            .repositionMarkerContainer();\n    }\n\n    /**\n     * draws all visible tiles\n     * @return {View} instance of View for chaining\n     */\n    drawVisibleTiles() {\n        Helper.forEach(this.visibleTiles, (tile) => tile.draw());\n        return this;\n    }\n\n    /**\n     * draws the thumbnail\n     * @return {View} instance of View for chaining\n     */\n    drawThumbnail() {\n        const rect = this.currentView.getDistortedRect(this.distortionFactor).translate(this.offsetToCenter, 0);\n        this.context.drawImage(this.thumb, 0, 0, this.thumb.width, this.thumb.height, rect.x, rect.y, rect.width, rect.height);\n        return this;\n    }\n\n    /**\n     * initializes tiles\n     * @return {View} instance of View for chaining\n     */\n    initializeTiles() {\n        const currentLevel = this.data.tiles;\n        Helper.forEach(currentLevel, (currentTileData) => {\n            this.tiles.push(new Tile(currentTileData, this));\n        });\n        return this;\n    }\n\n    /**\n     * reposition marker container\n     * @return {View} instance of View for chaining\n     */\n    repositionMarkerContainer() {\n        if (this.$markerContainer) {\n            const newSize = this.currentView.getDistortedRect(this.distortionFactor);\n            this.$markerContainer.css({\n               \"width\": `${newSize.width}px`,\n               \"height\": `${newSize.height}px`,\n               \"left\": `${newSize.left + this.offsetToCenter}px`,\n               \"top\": `${newSize.top}px`\n            });\n        }\n        return this;\n    }\n\n}\n\n/**\n * request animation frame browser polyfill\n * @return {Function} supported requestAnimationFrame-function\n */\nwindow.requestAnimFrame = (function(){\n  return window.requestAnimationFrame       ||\n         window.webkitRequestAnimationFrame ||\n         window.mozRequestAnimationFrame    ||\n         function( callback ){\n             window.setTimeout(callback, 1000 / 60);\n         };\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/View.js\n **/","/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents latitude and longitude coordinates in a geographic coordinate system\n * @copyright Michael Duve 2016\n */\nexport class LatLng {\n\n    /**\n     * length of a latlng\n     * @return {number} length of a latlng\n     */\n    get length() {\n        return Math.sqrt(Math.pow(this.lat, 2) + Math.pow(this.lng, 2));\n    }\n\n    /**\n     * gets a clone of this latlng\n     * @return {LatLng} create a copy\n     */\n    get clone() {\n        return LatLng.createFromLatLng(this);\n    }\n\n    /**\n     * @constructor\n     * @param  {number} lat = 0 - representation of latitude\n     * @param  {number} lng = 0 - representation of longitude\n     * @return {LatLng} instance of LatLng for chaining\n     */\n    constructor(lat = 0, lng = 0) {\n        this.lat = lat;\n        this.lng = lng;\n        return this;\n    }\n\n    /**\n     * substract specified coord from this coordinate\n     * @param  {LatLng} coord = new LatLng() - specified coordinate to substract from this coord\n     * @return {LatLng} instance of LatLng for chaining\n     */\n    substract(coord = new LatLng()) {\n        this.lat -= coord.lat;\n        this.lng -= coord.lng;\n        return this;\n    }\n\n    /**\n     * add specified coord to this coordinate\n     * @param  {LatLng} coord = new LatLng() - specified coordinate to add to this coord\n     * @return {LatLng} instance of LatLng for chaining\n     */\n    add(coord = new LatLng()) {\n        this.lat += coord.lat;\n        this.lng += coord.lng;\n        return this;\n    }\n\n    /**\n    * divides a latlng with a given factor\n    * @param  {number} factorLat = 1 - factor to divide lat with\n    * @param  {number} factorLng = factorLat - factor to divide lng with\n    * @return {LatLng} instance of LatLng for chaining\n    */\n    divide(factorLat = 1, factorLng = factorLat) {\n        this.lat /= factorLat;\n        this.lng /= factorLng;\n        return this;\n    }\n\n    /**\n     * multiplicates a latlng with a given factor\n     * @param  {number} factorLat = 1 - factor to multiplicate lat with\n     * @param  {number} factorLng = factorLat - factor to multiplicate lng with\n     * @return {LatLng} instance of LatLng for chaining\n     */\n    multiply(factorLat = 1, factorLng = factorLat) {\n        this.lat *= factorLat;\n        this.lng *= factorLng;\n        return this;\n    }\n\n    /**\n     * checks if specified coord equals this coord\n     * @param  {LatLng} coord - specified coord to check against\n     * @return {Boolean} Returns if specified coord equals this coord\n     */\n    equals(coord) {\n        return this.lat === coord.lat && this.lng === coord.lng;\n    }\n\n    /**\n     * converts a LatLng to string\n     * @return {string} representing LatLng\n     */\n    toString() {\n        return `(${this.lat}, ${this.lng})`;\n    }\n\n}\n\n/**\n * Creates a LatLng from specified LatLng\n * @param  {LatLng} LatLng - specified LatLng\n * @return {LatLng} the LatLng specified\n */\nLatLng.createFromLatLng = (latlng) => new LatLng(latlng.lat, latlng.lng);\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/LatLng.js\n **/","import {LatLng} from './LatLng.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents boundaries of a geographic coordinate system\n * @copyright Michael Duve 2016\n */\nexport class Bounds {\n\n    /**\n     * get width of boundaries\n     * @return {number} distance between east and west boundary\n     */\n    get width() {\n        return Math.abs(this.se.lng - this.nw.lng);\n    }\n\n    /**\n     * get height of boundaries\n     * @return {number} distance between north and south boundary\n     */\n    get height() {\n        return Math.abs(this.se.lat - this.nw.lat);\n    }\n\n    /**\n     * @constructor\n     * @param  {number} northWest = new LatLng() - representation of northWest boundary\n     * @param  {number} southEast = new LatLng() - representation of southEast boundary\n     * @return {Bounds} instance of Bounds for chaining\n     */\n    constructor(northWest = new LatLng(), southEast = new LatLng()) {\n        if (northWest.lat < southEast.lat || northWest.lng > southEast.lng) throw new Error(`${northWest} needs to be top-right corner and ${southEast} bottom-left`);\n        this.nw = northWest;\n        this.se = southEast;\n        return this;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Bounds.js\n **/","import {Helper} from './Helper.js';\nimport {StateHandler} from './StateHandler.js';\nimport {Rectangle} from './Rectangle.js';\n\n/**\n * States of a tile\n * @type {Array}\n */\nconst STATES = [\n    {value: 0, description: 'Starting'},\n    {value: 1, description: 'Initialized'},\n    {value: 2, description: 'Loaded'},\n    {value: 3, description: 'Drawn'}\n];\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file Represents a part of the background map\n * @extends Rectangle\n * @copyright Michael Duve 2016\n */\nexport class Tile extends Rectangle {\n\n    /**\n     * @constructor\n     * @param  {string} path = null - path to image\n     * @param  {number} x = 0 - position x of tile\n     * @param  {number} y = 0 - position y of tile\n     * @param  {number} w = 0 - tile width\n     * @param  {number} h = 0 - tile height\n     * @param  {View} _instance = null - instance of parent View\n     * @return {Tile} instance of Tile for chaining\n     */\n    constructor({path = null, x = 0, y = 0, w = 0, h = 0} = {}, _instance = null) {\n        super(x, y, w, h);\n\n        if (!path || typeof path !== \"string\" || path.length === 0) throw new TypeError(`Path ${path} needs to be of type string and should not be empty`);\n        else if(!_instance) throw new Error(`Tile needs an instance`);\n\n        this.state = new StateHandler(STATES);\n        this.instance = _instance;\n        this.context = this.instance.context;\n        this.path = path;\n\n        return this;\n    }\n\n    /**\n     * initializes tile and starts loading image\n     * @return {Tile} instance of Tile for chaining\n     */\n    initialize() {\n        this.state.next();\n        Helper.loadImage(this.path, (img) => {\n            this.img = img;\n            this.state.next();\n            this.draw();\n        });\n        return this;\n    }\n\n    /**\n     * draws image data of tile on context\n     * @return {Tile} instance of Tile for chaining\n     */\n    draw() {\n        const distortedTile = this.clone.scale(this.instance.zoomFactor)\n                                        .translate(this.instance.currentView.x, this.instance.currentView.y)\n                                        .scaleX(this.instance.distortionFactor)\n                                        .translate(this.instance.offsetToCenter, 0);\n        if (this.state.current.value >= 2) {\n            if (!this.context) {\n                console.error(\"context not specified\", this);\n                return false;\n            }\n            this.state.next();\n            this.context.drawImage(this.img, distortedTile.x, distortedTile.y, distortedTile.width, distortedTile.height);\n        } else if (this.state.current.value === 0) {\n            this.initialize();\n        }\n        return this;\n    }\n\n    /**\n     * check if tiles are equal\n     * @param  {Tile} tile - the specified tile to check against this\n     * @return {Boolean} is true, if x, y, width and height and path are the same\n     */\n    equals(tile) {\n        return (tile instanceof Tile) ? super.equals(tile) && this.path === tile.path : false;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Tile.js\n **/","import {Cluster} from './Cluster.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents a class which helps clustering overlapping markers\n * @copyright Michael Duve 2016\n */\nexport class MarkerClusterer {\n    /**\n     * @constructor\n     * @return {MarkerClusterer} instance of MarkerClusterer for chaining\n     */\n    constructor({markers = [], $container = null, view = null}) {\n        this.markers = markers;\n        this.$container = $container;\n        this.view = view;\n        this.clusters = [];\n        this.clusterize();\n        return this;\n    }\n\n    clusterize() {\n        this.deleteAllClusters();\n        for (const [i, marker] of this.markers.entries()) {\n            const hits = [];\n            for (const [j, cluster] of this.clusters.entries()) {\n                if (marker.boundingBox.intersects(cluster.boundingBox)) {\n                    hits.push(cluster);\n                }\n            }\n            if (!hits.length) {\n                const newCluster = this.createCluster(marker);\n                this.clusters.push(newCluster);\n            } else {\n                const nearestCluster = this.findNearestHit(marker, hits);\n                nearestCluster.addMarker(marker);\n            }\n        }\n        for (const [i, cluster] of this.clusters.entries()) {\n            cluster.init();\n        }\n    }\n\n    findNearestHit(marker, hits) {\n        let lastDistance,\n            minimalHit;\n        for (const [i, hit] of hits.entries()) {\n            if (!lastDistance) {\n                lastDistance = this.getDistance(marker, hit);\n                minimalHit = hit;\n            } else {\n                const currentDistance = this.getDistance(marker, hit);\n                if (currentDistance < lastDistance) {\n                    lastDistance = currentDistance;\n                    minimalHit = hit;\n                }\n            }\n        }\n        return minimalHit;\n    }\n\n    getDistance(marker, cluster) {\n        return marker.boundingBox.center.distance(cluster.boundingBox.center);\n    }\n\n    createCluster(marker) {\n        const newCluster = new Cluster({\n            $container: this.$container,\n            view: this.view\n        });\n        newCluster.addMarker(marker);\n        return newCluster;\n    }\n\n    deleteAllClusters() {\n        for (const [i, cluster] of this.clusters.entries()) {\n            cluster.removeFromDOM();\n        }\n        this.clusters = [];\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/MarkerClusterer.js\n **/","import $ from 'jQuery';\nimport {Point} from './Point.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents a cluster of markers\n * @copyright Michael Duve 2016\n */\nexport class Cluster {\n    /**\n     * @constructor\n     * @return {Cluster} instance of Cluster for chaining\n     */\n    constructor({$container = null, view = null}) {\n        this.markers = [];\n        this.$container = $container;\n        this.view = view;\n        return this;\n    }\n\n    init() {\n        if (this.markers.length === 1) {\n            this.markers[0].$icon.show();\n        } else {\n            this.createClusterMarker();\n        }\n    }\n\n    createClusterMarker() {\n        let p;\n        for (const marker of this.markers) {\n            marker.$icon.hide();\n            const currentPos = new Point(parseFloat(marker.icon.style.left), parseFloat(marker.icon.style.top));\n            p = (!p) ? currentPos : p.add(currentPos);\n        }\n        p.divide(this.markers.length);\n\n        this.$cluster = $(\"<div class='cluster'>\"+this.markers.length+\"</div>\").css({\n            \"left\": `${p.x}%`,\n            \"top\": `${p.y}%`,\n            \"margin-left\": `-16px`,\n            \"margin-top\": `-16px`\n        });\n        this.$container.append(this.$cluster);\n        this.bindEvents();\n    }\n\n    bindEvents() {\n        this.$cluster.on(\"mouseenter\", () => {\n            for (const marker of this.markers) {\n                marker.$icon.fadeIn(500);\n            }\n        });\n\n        this.$cluster.on(\"mouseleave\", () => {\n            for (const marker of this.markers) {\n                marker.$icon.fadeOut(500);\n            }\n        });\n    }\n\n    addMarker(marker) {\n        this.markers.push(marker);\n        this.boundingBox = (!this.boundingBox) ? marker.boundingBox : this.boundingBox.extend(marker.boundingBox);\n    }\n\n    removeFromDOM() {\n        if (this.markers.length > 1) {\n            for (const marker of this.markers) {\n                marker.$icon.show();\n            }\n            this.$cluster.remove();\n        }\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Cluster.js\n **/","import $ from 'jQuery';\nimport {Events} from './Events.js';\nimport {Helper} from './Helper.js';\nimport {Point} from './Point.js';\nimport {Rectangle} from './Rectangle.js';\nimport {Publisher} from './Publisher.js';\nimport {DataEnrichment} from './DataEnrichment.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents a marker with an image, a position and content\n * @copyright Michael Duve 2016\n */\nexport class Marker {\n\n    get boundingBox() {\n        const bBox = this.icon.getBoundingClientRect();\n        return new Rectangle(bBox.left, bBox.top, bBox.width, bBox.height);\n    }\n\n    /**\n     * @constructor\n     * @param  {Object} data = DataEnrichment.DATA_MARKER - enriched data\n     * @param  {View} _instance = parent instance - instance of parent view\n     * @return {Marker} - instance of Marker for chaining\n     */\n    constructor(data = DataEnrichment.DATA_MARKER, _instance = null) {\n\n        if(!_instance) throw new Error(`Tile needs an instance`);\n        this.instance = _instance;\n\n        this.id = Marker.count;\n        Marker.count++;\n\n        this.size = data.size;\n\n        this.hover = data.hover;\n        if (this.hover) this.size.divide(2, 1);\n\n        this.img = data.icon;\n        this.offset = data.offset.add(new Point(-(this.size.x/2), -this.size.y));\n        this.latlng = data.latlng;\n\n        this.content = data.content;\n        this.$icon = this.addMarkerToDOM(this.instance.$markerContainer);\n        this.icon = this.$icon[0];\n\n        return this.bindEvents().positionMarker();\n    }\n\n    /**\n     * binds all events\n     * @return {Marker} instance of Marker for chaining\n     */\n    bindEvents() {\n        this.eventManager = new Publisher();\n\n        const gesture = Helper.isTouch() ? Events.Handling.TOUCHSTART: Events.Handling.CLICK;\n        if (this.content.length) {\n            this.$icon.on(gesture, () => {\n                this.eventManager.publish(Events.ToolTip.OPEN, this.content);\n                this.eventManager.publish(Events.Marker.DEACTIVATE);\n                this.$icon.addClass(\"active\");\n            });\n\n            this.eventManager.subscribe(Events.Marker.DEACTIVATE, () => {\n                this.$icon.removeClass(\"active\");\n            });\n        }\n\n        return this;\n    }\n\n    /**\n     * adds a marker to the DOM\n     * @param {Object} $container - container to append to (jQuery selector)\n     * @returns {Object} jQuery-selector of append markup\n     */\n    addMarkerToDOM($container) {\n        const icon = $(\"<div class='marker' />\").css({\n            \"width\": `${this.size.x}px`,\n            \"height\": `${this.size.y}px`,\n            \"margin-left\": `${this.offset.x}px`,\n            \"margin-top\": `${this.offset.y}px`,\n            \"background-image\": `url(${this.img})`,\n            \"background-size\": `${(this.hover) ? this.size.x*2 : this.size.x}px ${this.size.y}px`\n        });\n        if ($container) {\n            icon.hide();\n            $container.append(icon);\n        }\n        return icon;\n    }\n\n    /**\n     * set initial position of this marker\n     * @return {Marker} instance of Marker for chaining\n     */\n    positionMarker() {\n        this.position = this.instance.convertLatLngToPoint(this.latlng);\n        if (this.$icon) {\n            this.$icon.css({\n                \"left\": `${this.position.x / this.instance.currentView.width * 100}%`,\n                \"top\": `${this.position.y / this.instance.currentView.height * 100}%`\n            }).show();\n        }\n        return this;\n    }\n\n}\n\nMarker.count = 0;\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Marker.js\n **/","import $ from 'jQuery';\nimport {Helper} from './Helper.js';\nimport {Point} from './Point.js';\nimport {LatLng} from './LatLng.js';\nimport {Bounds} from './Bounds.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file enriches delivered data with default values\n * @copyright Michael Duve 2016\n * @module DataEnrichment\n */\nexport var DataEnrichment = {\n    /**\n     * enriches marker data with all needed data\n     * @function\n     * @memberof module:DataEnrichment\n     * @param  {object} data - specified data for marker\n     * @return {object} enriched marker data\n     */\n    marker(data) {\n\n        const enrichedData = [];\n\n        Helper.forEach(data, (entry) => {\n            entry = Object.assign(DataEnrichment.DATA_MARKER, entry);\n\n            const offset = new Point(entry.offset.x, entry.offset.y),\n                  latlng = new LatLng(entry.position.lat, entry.position.lng),\n                  size = new Point(entry.size.width, entry.size.height);\n\n            enrichedData.push({\n                offset: offset,\n                latlng: latlng,\n                size: size,\n                hover: entry.hover,\n                icon: entry.icon,\n                content: entry.content\n            });\n        });\n\n        return enrichedData;\n    },\n    /**\n     * enriches map data with all needed data\n     * @function\n     * @memberof module:DataEnrichment\n     * @param  {object} data - specified data for mapsettings\n     * @return {object} enriched mapsettings data\n     */\n    mapSettings(data) {\n\n        const enrichedData = Object.assign(DataEnrichment.MAP_SETTINGS, data),\n              bounds = new Bounds(new LatLng(enrichedData.bounds.northWest[0], enrichedData.bounds.northWest[1]), new LatLng(enrichedData.bounds.southEast[0], enrichedData.bounds.southEast[1])),\n              center = new LatLng(enrichedData.center.lat, enrichedData.center.lng);\n\n        if (!enrichedData.limitToBounds) {\n            enrichedData.limitToBounds = bounds;\n        } else {\n            enrichedData.limitToBounds =  new Bounds(new LatLng(enrichedData.limitToBounds.northWest[0], enrichedData.limitToBounds.northWest[1]), new LatLng(enrichedData.limitToBounds.southEast[0], enrichedData.limitToBounds.southEast[1]));\n        }\n\n        enrichedData.bounds = bounds;\n        enrichedData.center = center;\n\n        return enrichedData;\n    }\n};\n\n/**\n * Default initial values for a Marker\n * @type {Object}\n */\nDataEnrichment.DATA_MARKER = {\n    icon: null,\n    hover: false,\n    position: {\n        lat: 0,\n        lng: 0\n    },\n    offset: {\n        x: 0,\n        y: 0\n    },\n    size: {\n        width: 32,\n        height: 32\n    },\n    content: []\n};\n/**\n * Default initial values for a Map\n * @type {Object}\n */\nDataEnrichment.MAP_SETTINGS = {\n    level: 0,\n    center: {\"lat\": 0, \"lng\": 0},\n    bounds: {\n        \"northWest\": [90, -180],\n        \"southEast\": [-90, 180]\n    },\n    controls: {\n        zoom: false,\n        home: false,\n        position: \"bottom-right\",\n        theme: \"dark\"\n    }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/DataEnrichment.js\n **/","import $ from 'jQuery';\nimport Handlebars from 'Handlebars';\nimport {Events} from './Events.js';\nimport {Helper} from './Helper.js';\nimport {Publisher} from './Publisher.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file represents an overlay showing detailed contents\n * @copyright Michael Duve 2016\n */\nexport class ToolTip {\n\n    /**\n     * checks if all templates were loaded\n     * @return {boolean} wheter true if all templates were loaded or false\n     */\n    get allTemplatesLoaded() {\n        return this.loadedTemplates === Object.keys(this.templates).length;\n    }\n\n    /**\n     *\n     * @constructor\n     * @param  {string|object} container - Container, either string, jQuery-object or dom-object\n     * @param  {object} templates - defined templates\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    constructor({container, templates}) {\n        this.$container = (typeof container === \"string\") ? $(container) : ((typeof container === \"object\" && container instanceof jQuery) ? container : $(container));\n        if (!(this.$container instanceof jQuery)) throw new Error(\"Container \" + container + \" not found\");\n\n        this.$container.addClass(Events.ToolTip.CLOSE);\n\n        this.$close = $(`<span class='close-button' />`);\n        this.$content = $(`<div class='tooltip-content' />`);\n        this.$popup = $(`<div class='tooltip-container' />`).append(this.$close)\n                                                            .append(this.$content);\n        this.eventManager = new Publisher();\n\n        this.bindEvents();\n        this.registerHandlebarHelpers();\n\n        return this.setPosition().initializeTemplates(templates);\n    }\n\n    /**\n     * register helpers for handlebars\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    registerHandlebarHelpers() {\n        if (Handlebars) {\n            Handlebars.registerHelper('getRatio', (w, h) => (h/w * 100 + \"%\"));\n        }\n        return this;\n    }\n\n    /**\n     * initialize all templates\n     * @param  {object} templates = {} - all specified templates\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    initializeTemplates(templates = {}) {\n        this.templates = Object.assign(this.getDefaultTemplates(), templates);\n        this.loadedTemplates = 0;\n        this.compileTemplates();\n        return this;\n    }\n\n    /**\n     * // TODO: move to DataEnrichment\n     * returns paths to default templates\n     * @return {object} default templates\n     */\n    getDefaultTemplates() {\n        return {\n            image: \"/plugin/src/hbs/image.hbs\",\n            text: \"/plugin/src/hbs/text.hbs\",\n            headline: \"/plugin/src/hbs/headline.hbs\",\n            crossheading: \"/plugin/src/hbs/crossheading.hbs\",\n            iframe: \"/plugin/src/hbs/iframe.hbs\"\n        };\n    }\n\n    /**\n     * bind all events\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    bindEvents() {\n        $(window).on(Events.Handling.RESIZE, () => { this.resizeHandler(); });\n        this.eventManager.subscribe(Events.ToolTip.OPEN, this.open.bind(this));\n        this.eventManager.subscribe(Events.ToolTip.CLOSE, () => { this.close(); });\n        this.$close.on(Events.Handling.CLICK, () => { this.close(); });\n        return this;\n    }\n\n    /**\n     * on resize check if tooltip is bottom or left position\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    resizeHandler() {\n        this.setPosition();\n        return this;\n    }\n\n    /**\n     * inserts content to ToolTip instance container\n     * @param  {object} content = {} - content object\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    insertContent(content = {}) {\n        this.$content.html(\"\");\n        Helper.forEach(content, (data) => {\n            if (this.templates[data.type]) {\n                const html = this.templates[data.type](data.content);\n                this.$content.append(html);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * opens a tooltip\n     * @param  {object} data - content object\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    open(data) {\n        if (data) this.insertContent(data);\n        if (this.$container.hasClass(Events.ToolTip.CLOSE)) {\n            this.setPosition();\n            this.$container.removeClass(Events.ToolTip.CLOSE).addClass(Events.ToolTip.OPEN);\n            this.eventManager.publish(Events.TileMap.RESIZE);\n        }\n        return this;\n    }\n\n    /**\n     * closes a tooltip\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    close() {\n        if (this.$container.hasClass(Events.ToolTip.OPEN)) {\n            this.eventManager.publish(Events.Marker.DEACTIVATE);\n            this.setPosition();\n            this.$container.removeClass(Events.ToolTip.OPEN).addClass(Events.ToolTip.CLOSE);\n            this.eventManager.publish(Events.TileMap.RESIZE);\n        }\n        return this;\n    }\n\n    /**\n     * sets position of tooltip to left or bottom\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    setPosition() {\n        if (this.$container.innerWidth() > this.$container.innerHeight()) {\n            this.$container.addClass(\"left\").removeClass(\"bottom\");\n        } else {\n            this.$container.addClass(\"bottom\").removeClass(\"left\");\n        }\n        return this;\n    }\n\n    /**\n     * precompiles all Handlebars templates\n     * @return {ToolTip} instance of ToolTip for chaining\n     */\n    compileTemplates() {\n        Helper.forEach(this.templates, (template, type) => {\n            this.getTemplateFromFile(template, (compiledTemplate) => {\n                this.templates[type] = compiledTemplate;\n                this.loadedTemplates++;\n                if (this.allTemplatesLoaded) this.$container.append(this.$popup);\n            });\n        });\n        return this;\n    }\n\n    // TODO: move to Helper\n    getTemplateFromFile(url, cb) {\n        $.get(url, function (data) {\n            cb(Handlebars.compile(data));\n        }, 'html');\n        return this;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/ToolTip.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_18__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"Handlebars\"\n ** module id = 18\n ** module chunks = 0\n **/","/*global PointerEvent,MSPointerEvent*/\nimport $ from 'jQuery';\nimport {Point} from './Point.js';\nimport {Helper} from './Helper.js';\n\n/**\n * @author Michael Duve <mduve@designmail.net>\n * @file implements interaction like panning, zooming, flicking and more, cross-browser and cross-device\n * @copyright Michael Duve 2016\n */\nexport class Interact {\n    /**\n     * get time difference to last\n     * @return {number} difference\n     */\n    get timeToLastMove() {\n        return this.data.time.end - this.data.time.last;\n    }\n\n    /**\n     * get time difference to start\n     * @return {number} difference\n     */\n    get time() {\n        return this.data.time.end - this.data.time.start;\n    }\n\n    /**\n     * clones the data object\n     * @return {Object} data object\n     */\n    get dataClone() {\n        return $(this.data)[0];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} settings = {} - all the settings\n     * @param {string|Object} settings.container = \".interact-container\" - Container, either string, jQuery-object or dom-object\n     * @param {Object} settings.timeTreshold = {} - settings for the timing tresholds\n     * @param {number} settings.timeTreshold.tap = 200 - timing treshold for tap\n     * @param {number} settings.timeTreshold.hold = 500 - timing treshold for hold\n     * @param {number} settings.timeTreshold.swipe = 300 - timing treshold for swipe\n     * @param {number} settings.timeTreshold.flick = 30 - timing treshold for flick\n     * @param {Object} settings.distanceTreshold = {} - settings for the distance tresholds\n     * @param {number} settings.distanceTreshold.swipe = 200 - distance treshold for swipe\n     * @param {Boolean|string} settings.overwriteViewportSettings = false - on true prevents pinching, can be a custom string too\n     * @param {Boolean} settings.stopPropagation = true - on true stops the propagation of events\n     * @param {Boolean} settings.preventDefault = true - on true prevents the default actions of events\n     * @param {Boolean} settings.autoFireHold = false - if set to false hold-event is not fired\n     * @param {number} settings.pinchBalanceTime = 50 - prevents from firing too much pinching events\n     * @param {Object} settings.callbacks = {} - settings for the callback-functions\n     * @param {function} settings.callbacks.tap = null - callback-function for tap\n     * @param {function} settings.callbacks.tapHold = null - callback-function for tapHold\n     * @param {function} settings.callbacks.doubletap = null - callback-function for doubletap\n     * @param {function} settings.callbacks.hold = null - callback-function for hold\n     * @param {function} settings.callbacks.pan = null - callback-function for pan\n     * @param {function} settings.callbacks.swipe = null - callback-function for swipe\n     * @param {function} settings.callbacks.flick = null - callback-function for flick\n     * @param {function} settings.callbacks.zoom = null - callback-function for zoom\n     * @param {function} settings.callbacks.wheel = null - callback-function for wheel\n     * @param {function} settings.callbacks.pinch = null - callback-function for pinch\n     * @param {Object} settings.events = {} - settings all eventnames\n     * @param {Object} settings.events.start = {} - settings all start eventnames\n     * @param {Object} settings.events.start.touch = (\"MSPointerDown pointerdown\" || \"touchstart\") - settings start touch eventnames\n     * @param {Object} settings.events.start.mouse = (\"MSPointerDown pointerdown\" || \"mousedown\") - settings start mouse eventnames\n     * @param {Object} settings.events.move = {} - settings all move eventnames\n     * @param {Object} settings.events.move.touch = (\"MSPointerMove pointermove\" || \"touchmove\") - settings move touch eventnames\n     * @param {Object} settings.events.move.mouse = (\"MSPointerMove pointermove\" || \"mousemove\") - settings move mouse eventnames\n     * @param {Object} settings.events.end = {} - settings all end eventnames\n     * @param {Object} settings.events.end.touch = (\"MSPointerUp pointerup\" || \"touchend\") - settings end touch eventnames\n     * @param {Object} settings.events.end.mouse = (\"MSPointerUp pointerup\" || \"mouseup\") - settings end mouse eventnames\n     * @param {Object} settings.events.leave = {} - settings all leave eventnames\n     * @param {Object} settings.events.leave.touch = (\"MSPointerLeave pointerleave\" || \"touchleave\") - settings leave touch eventnames\n     * @param {Object} settings.events.leave.mouse = (\"MSPointerLeave pointerleave\" || \"mouseleave\") - settings leave mouse eventnames\n     * @param {string} settings.events.scroll = (\"wheel\" || \"mousewhell\" || \"DOMMouseScroll\") - settings all scroll eventnames\n     * @return {Interact} new instance\n     */\n    constructor(settings = {}) {\n        this.settings = Object.assign(this.getDefaultSettings(), settings);\n        this.data = this.getDefaultData();\n        if (this.settings.overwriteViewportSettings) this.handleViewport(this.settings.overwriteViewportSettings);\n        this.init(this.settings.container).bindEvents();\n    }\n\n    /**\n     * get the default settings\n     * @return {Object} settings\n     */\n    getDefaultSettings() {\n        return {\n            container: \".interact-container\",\n            timeTreshold: {\n                tap: 200,\n                hold: 500,\n                swipe: 300,\n                flick: 20\n            },\n            distanceTreshold: {\n                swipe: 200\n            },\n            speedThreshold: 0.01,\n            overwriteViewportSettings: false,\n            stopPropagation: true,\n            preventDefault: true,\n            autoFireHold: false,\n            pinchBalanceTime: 500,\n            callbacks: this.getDefaultCallbacks(),\n            events: this.getDefaultEventNames()\n        };\n    }\n\n    /**\n     * get default callbacks\n     * @return {Object} callbacks\n     */\n    getDefaultCallbacks() {\n        return {\n            tap: null,\n            tapHold: null,\n            doubletap: null,\n            hold: null,\n            pan: null,\n            swipe: null,\n            flick: null,\n            zoom: null,\n            wheel: null,\n            pinch: null\n        };\n    }\n\n    /**\n     * get default eventnames\n     * @return {Object} eventnames\n     */\n    getDefaultEventNames() {\n        const isIE = Helper.isIE();\n        return {\n            start: {\n                touch: (isIE) ? \"MSPointerDown pointerdown\" : \"touchstart\",\n                mouse: (isIE) ? \"MSPointerDown pointerdown\" : \"mousedown\"\n            },\n            move: {\n                touch: (isIE) ? \"MSPointerMove pointermove\" : \"touchmove\",\n                mouse: (isIE) ? \"MSPointerMove pointermove\" : \"mousemove\"\n            },\n            end: {\n                touch: (isIE) ? \"MSPointerUp pointerup\" : \"touchend\",\n                mouse: (isIE) ? \"MSPointerUp pointerup\" : \"mouseup\"\n            },\n            leave: {\n                touch: (isIE) ? \"MSPointerLeave pointerleave\" : \"touchleave\",\n                mouse: (isIE) ? \"MSPointerLeave pointerleave\" : \"mouseleave\"\n            },\n            scroll: Helper.scrollEvent()\n        };\n    }\n\n    /**\n     * get default data\n     * @return {Object} data\n     */\n    getDefaultData() {\n        return {\n            down: false,\n            moved: false,\n            pinched: false,\n            pointerArray: {},\n            multitouch: false,\n            distance: null,\n            directions: [],\n            zoom: 0,\n            difference: null,\n            target: null,\n            last: {\n                position: null,\n                distance: null,\n                action: null\n            },\n            position: {\n                start: null,\n                move: null,\n                end: null\n            },\n            time: {\n                start: null,\n                last: null,\n                end: null\n            },\n            timeout: {\n                hold: null,\n                default: null\n            }\n        };\n    }\n\n    /**\n     * handles the overwrite of viewport meta\n     * @param  {Boolean|string} viewport - specified viewport option\n     * @return {Interact} Returns this instance\n     */\n    handleViewport(viewport) {\n        if (typeof viewport !== \"string\") {\n            viewport = \"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\";\n        }\n        const metaViewInHead = $(\"meta[name=viewport]\").length,\n              $viewportMeta = (metaViewInHead !== 0) ? $(\"meta[name=viewport]\") : $(\"head\").append($(\"<meta name='viewport' />\"));\n        $viewportMeta.attr(\"content\", viewport);\n        return this;\n    }\n\n    /**\n     * initializes class settings and bindings\n     * @param  {Object|string} container - Container, either string, jQuery-object or dom-object\n     * @return {Interact} Returns this instance\n     */\n    init(container) {\n        this.$container = (typeof container === \"string\") ? $(container) : ((typeof container === \"object\" && container instanceof jQuery) ? container : $(container));\n        if (!(this.$container instanceof jQuery)) throw new Error(\"Container \" + container + \" not found\");\n        const css = {\n            \"-ms-touch-action\": \"none\",\n            \"touch-action\": \"none\",\n            \"-ms-content-zooming\": \"none\"\n        };\n        this.$container.css(css);\n        this.$container.find(\"> *\").css(css);\n        this.container = this.$container[0];\n        return this;\n    }\n\n    /**\n     * binds all needed events\n     * @return {Interact} Returns this instance\n     */\n    bindEvents() {\n        if (Helper.isIE()) {\n            this.bindIEEvents();\n        } else {\n            if (Helper.isTouch()) this.bindTouchEvents();\n            if (Helper.isMouse()) this.bindMouseEvents();\n        }\n        return this;\n    }\n\n    /**\n     * binds all needed events for IE\n     * @return {Interact} Returns this instance\n     */\n    bindIEEvents() {\n        this.$container.on(this.settings.events.scroll, this.scrollHandler.bind(this));\n        this.bindTouchEvents();\n        this.container.addEventListener(\"contextmenu\", (e) => e.preventDefault(), false);\n        return this;\n    }\n\n    /**\n     * binds all needed events for touch devices\n     * @return {Interact} Returns this instance\n     */\n    bindTouchEvents() {\n        this.$container\n            .on(this.settings.events.start.touch, this.startHandler.bind(this))\n            .on(this.settings.events.move.touch, this.moveHandler.bind(this))\n            .on(this.settings.events.end.touch, this.endHandler.bind(this))\n            .on(this.settings.events.leave.touch, this.endHandler.bind(this));\n        return this;\n    }\n\n    /**\n     * binds all needed events for mouse devices\n     * @return {Interact} Returns this instance\n     */\n    bindMouseEvents() {\n        this.$container.on(this.settings.events.scroll, this.scrollHandler.bind(this))\n            .on(this.settings.events.start.mouse, this.startHandler.bind(this))\n            .on(this.settings.events.move.mouse, this.moveHandler.bind(this))\n            .on(this.settings.events.end.mouse, this.endHandler.bind(this))\n            .on(this.settings.events.leave.mouse, this.endHandler.bind(this));\n        return this;\n    }\n\n    /**\n     * pre handle all events\n     * @param  {Object} event - original event of Vanilla JS\n     * @return {Object} normalized jQuery-fixed event\n     */\n    preHandle(event) {\n        if (this.settings.stopPropagation) event.stopPropagation();\n        if (this.settings.preventDefault) event.preventDefault();\n        this.data.target = event.target;\n        return this.getEvent(event);\n    }\n\n    /**\n     * handles cross-browser and -device scroll\n     * @param  {Object} event - jQuery-Event-Object\n     * @return {Boolean} always returns false\n     */\n    scrollHandler(event) {\n        event = event || window.event;\n\n        const e = this.preHandle(event) || event.originalEvent;\n\n        this.data.delta = this.normalizeWheelDelta(event);\n        this.data.position.start = this.getRelativePosition(e);\n        this.data.directions = this.getScrollDirection(e);\n        this.data.zoom = (this.data.directions.indexOf(\"up\") > -1) ? 1 : (this.data.directions.indexOf(\"down\") > -1) ? -1 : 0;\n\n        if (this.settings.callbacks.wheel) {\n            this.eventCallback(this.settings.callbacks.wheel, this.dataClone);\n        }\n        if (this.settings.callbacks.zoom && (this.data.directions.indexOf(\"up\") > -1 || this.data.directions.indexOf(\"down\") > -1)) {\n            this.eventCallback(this.settings.callbacks.zoom, this.dataClone);\n        }\n        return false;\n    }\n\n    /**\n     *\n     * Solution from http://jsfiddle.net/uNeBr/\n     * @param  {Object} event - VanillaJS-Event-Object\n     * @return {number} normalized wheel delta\n     */\n    normalizeWheelDelta(e) {\n        const o = e.originalEvent,\n            w = o.wheelDelta || (o.deltaY * -1) * 10,\n            n = 225,\n            n1 = n-1;\n\n        let d = o.detail,\n            f;\n\n        // Normalize delta\n        d = d ? w && (f = w/d) ? d/f : -d/1.35 : w/120;\n        // Quadratic scale if |d| > 1\n        d = d < 1 ? d < -1 ? (-Math.pow(d, 2) - n1) / n : d : (Math.pow(d, 2) + n1) / n;\n        // Delta *should* not be greater than 2...\n        return Math.min(Math.max(d / 2, -1), 1);\n    }\n\n    /**\n     * check if event is a PointerEvent (IE)\n     * @param  {Object} event - original event of Vanilla JS\n     * @return {Boolean} Whether event is PointerEvent\n     */\n    isPointerEvent(e) {\n        return Helper.isIE() && (e instanceof MSPointerEvent || e instanceof PointerEvent);\n    }\n\n    /**\n     * calculation to be made at start-handler\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} calculated data\n     */\n    calculateStart(e) {\n        const data = {\n            multitouch: false,\n            distance: 0,\n            down: true,\n            position: {\n                start: new Point()\n            }\n        };\n        // mouse is used\n        if (e instanceof MouseEvent && !this.isPointerEvent(e)) {\n            return $.extend(true, data, this.handleSingletouchStart(e));\n        }\n        // if is pointerEvent\n        if (this.isPointerEvent(e)) {\n            return this.handlePointerEventStart(data, e);\n        } // touch is used\n        else { // singletouch startet\n            return this.handleTouchEventStart(data, e);\n        }\n    }\n\n    /**\n     * handle PointerEvent calculations\n     * @param  {Object} data - current data\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} manipulated enriched data\n     */\n    handlePointerEventStart(data, e) {\n        this.data.pointerArray[e.pointerId] = e;\n        const getData = (Object.keys(this.data.pointerArray).length <= 1) ? this.handleSingletouchStart(e) : this.handleMultitouchStart(this.getPointerArray());\n        return $.extend(true, data, getData);\n    }\n\n    /**\n     * handle TouchEvent calculations for start\n     * @param  {Object} data - current data\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} manipulated enriched data\n     */\n    handleTouchEventStart(data, e) {\n        return this.handleTouchEvent(data, e, this.handleSingletouchStart.bind(this), this.handleMultitouchStart.bind(this));\n    }\n\n    /**\n     * get array of pointers (IE)\n     * @return {Object} array of pointerIDs\n     */\n    getPointerArray() {\n        const pointerPos = [];\n        for (const pointer in this.data.pointerArray) {\n            if (this.data.pointerArray[pointer]) {\n                pointerPos.push(this.data.pointerArray[pointer]);\n            }\n        }\n        return pointerPos;\n    }\n\n    /**\n     * handles multitouch for start\n     * @param  {Object} positionsArray - array of positions\n     * @return {Object} manipulated enriched data\n     */\n    handleMultitouchStart(positionsArray) {\n        const pos1 = this.getRelativePosition(positionsArray[0]),\n              pos2 = this.getRelativePosition(positionsArray[1]);\n        return {\n            multitouch: true,\n            distance: pos1.distance(pos2),\n            position: {\n                start: pos1.add(pos2).divide(2, 2)\n            }\n        };\n    }\n\n    /**\n     * handles singletouch for start\n     * @param  {Point} position - position of touch\n     * @return {Object} manipulated enriched data\n     */\n    handleSingletouchStart(position) {\n        return {\n            position: {\n                start: this.getRelativePosition(position)\n            }\n        };\n    }\n\n    /**\n     * handle action at start event handler\n     * @param  {String} action - last action made\n     * @return {Interact} instance of Interact for chaining\n     */\n    takeActionStart(action) {\n        switch (action) {\n            case null:\n                this.data.last.action = \"tap\";\n                if (this.settings.autoFireHold) {\n                    this.setTimeoutForEvent(this.settings.callbacks.hold, this.settings.autoFireHold, this.dataClone, true);\n                }\n                break;\n            case \"tap\":\n                this.data.last.action = \"doubletap\";\n                if (this.settings.autoFireHold) {\n                    this.setTimeoutForEvent(this.settings.callbacks.tapHold, this.settings.autoFireHold, this.dataClone, true);\n                }\n                break;\n            default:\n                break;\n        }\n        return this;\n    }\n\n    /**\n     * handles cross-browser and -device start-event\n     * @param  {Object} event - jQuery-Event-Object\n     * @return {Boolean} always returns false\n     */\n    startHandler(event) {\n        if (event.button && event.button !== 0) {\n            return false;\n        }\n        const e = this.preHandle(event);\n        this.data.time.start = event.timeStamp;\n        this.clearTimeouts(this.data.timeout.default);\n        this.data = $.extend(true, this.data, this.calculateStart(e));\n        this.takeActionStart(this.data.last.action);\n        return false;\n    }\n\n    /**\n     * clear timeout helper\n     * @param  {Object} timeout - timeout object to be cleared\n     * @return {Interact} instance of Interact for chaining\n     */\n    clearTimeouts(timeout) {\n        if (timeout) {\n            timeout = clearTimeout(timeout);\n        }\n        return this;\n    }\n\n    /**\n     * calculation to be made at move-handler\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} calculated data\n     */\n    calculateMove(e) {\n        const data = {\n            moved: true,\n            last: {\n                action: \"moved\"\n            },\n            position: {\n                move: new Point()\n            }\n        };\n\n        if (e instanceof MouseEvent && !this.isPointerEvent(e)) {\n            return $.extend(true, data, this.handleSingletouchMove(e));\n        } // if is pointerEvent\n        if (this.isPointerEvent(e)) {\n            return this.handlePointerEventMove(data, e);\n        } // touch is used\n        else {\n            return this.handleTouchEventMove(data, e);\n        }\n    }\n\n    /**\n     * handle PointerEvent at moving (IE)\n     * @param  {Object} data - specified input data\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} manipulated enriched data\n     */\n    handlePointerEventMove(data, e) {\n        this.data.pointerArray[e.pointerId] = e;\n        if (Object.keys(this.data.pointerArray).length <= 1) {\n            return $.extend(true, data, this.handleSingletouchMove(e));\n        } else {\n            const pointerPos = this.getPointerArray();\n            return $.extend(true, data, this.handleMultitouchMove(pointerPos));\n        }\n    }\n\n    /**\n     * handle TouchEvent calculations for move\n     * @param  {Object} data - current data\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} manipulated enriched data\n     */\n    handleTouchEventMove(data, e) {\n        return this.handleTouchEvent(data, e, this.handleSingletouchMove.bind(this), this.handleMultitouchMove.bind(this));\n    }\n\n    handleTouchEvent(data, e, fnSingle, fnMulti) {\n        const getData = (e.length === 1) ? fnSingle(e[0]) : fnMulti(e);\n        return $.extend(true, data, getData);\n    }\n\n    /**\n     * handles multitouch for move\n     * @param  {Object} positionsArray - array of positions\n     * @return {Object} manipulated enriched data\n     */\n    handleMultitouchMove(positionsArray) {\n        const pointerPos1 = this.getRelativePosition(positionsArray[0]);\n        const pointerPos2 = this.getRelativePosition(positionsArray[1]);\n        const pos = pointerPos2.clone.add(pointerPos1).divide(2);\n        return {\n            position: {\n                move: pos\n            },\n            distance: pointerPos1.distance(pointerPos2),\n            multitouch: true\n        };\n    }\n\n    /**\n     * handles singletouch for move\n     * @param  {Point} position - position\n     * @return {Object} manipulated enriched data\n     */\n    handleSingletouchMove(position) {\n        const pos = this.getRelativePosition(position);\n        return {\n            position: {\n                move: pos\n            },\n            distance: this.data.last.position.distance(pos),\n            multitouch: false\n        };\n    }\n\n    /**\n     * handles cross-browser and -device move-event\n     * @param  {Object} event - jQuery-Event-Object\n     * @return {Boolean} always returns false\n     */\n    moveHandler(event) {\n        // if touchstart event was not fired\n        if (!this.data.down || this.data.pinched) return false;\n\n        const e = this.preHandle(event);\n        this.data.time.last = event.timeStamp;\n        this.data.last.position = (this.data.position.move) ? this.data.position.move : this.data.position.start;\n        this.data.time.last = (this.data.time.last) ? this.data.time.last : this.data.time.start;\n\n        // if positions have not changed\n        if (this.positionDidNotChange(e)) return false;\n\n        this.clearTimeouts(this.data.timeout.default);\n        this.clearTimeouts(this.data.timeout.hold);\n        this.data = $.extend(true, this.data, this.calculateMove(e));\n\n        if (this.data.multitouch) {\n            this.handlePinchAndZoom();\n        } else {\n            this.eventCallback(this.settings.callbacks.pan, this.dataClone);\n        }\n        return false;\n    }\n\n    /**\n     * handles pinch and zoom\n     * @return {Interact} instance of Interact for chaining\n     */\n    handlePinchAndZoom() {\n        if (!this.data.last.distance) this.data.last.distance = this.data.distance;\n\n        this.data.difference = this.data.distance - this.data.last.distance;\n        if (Math.abs(this.data.difference) >= 0.005) {\n            if (this.settings.callbacks.pinch) this.eventCallback(this.settings.callbacks.pinch, this.dataClone);\n            if (this.settings.callbacks.zoom) this.eventCallback(this.settings.callbacks.zoom, this.dataClone);\n            this.data.last.distance = this.data.distance;\n        }\n        return this;\n    }\n\n    /**\n     * check if position has been changed\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Boolean} Whether or not position has changed\n     */\n    positionDidNotChange(e) {\n        return Helper.isIE() && (this.getRelativePosition(e).equals(this.data.last.position) || this.getRelativePosition(e).equals(this.data.position.start)) || (!Helper.isIE() && Helper.isTouch() && this.getRelativePosition(e[0]).equals(this.data.last.position));\n    }\n\n    /**\n     * calculation to be made at end-handler\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} calculated data\n     */\n    calculateEnd(e) {\n        const data = {\n            position: {\n                end: new Point()\n            }\n        };\n\n        if (e instanceof MouseEvent && !this.isPointerEvent(e)) {\n            return $.extend(true, data, this.handleSingletouchEnd(e));\n        } // if is pointerEvent\n        if (this.isPointerEvent(e)) {\n            const end = this.handleSingletouchEnd(e);\n            delete this.data.pointerArray[e.pointerId];\n            return $.extend(true, data, end);\n        } // touch is used\n        else {\n            // singletouch ended\n            if (e.length <= 1) {\n                return $.extend(true, data,  this.handleSingletouchEnd(e[0]));\n            }\n        }\n    }\n\n    /**\n     * handles singletouch for end\n     * @param  {Object} position - position\n     * @return {Object} manipulated enriched data\n     */\n    handleSingletouchEnd(position) {\n        return {\n            position: {\n                end: this.getRelativePosition(position)\n            }\n        };\n    }\n\n    /**\n     * handle action at end event handler\n     * @param  {String} action - last action made\n     * @return {Interact} instance of Interact for chaining\n     */\n    takeActionEnd(action) {\n        switch (action) {\n            case \"tap\":\n                if (this.time < this.settings.timeTreshold.hold) {\n                    this.setTimeoutForEvent(this.settings.callbacks.tap, this.settings.timeTreshold.tap, this.dataClone);\n                } else {\n                    this.eventCallback(this.settings.callbacks.hold, this.dataClone);\n                }\n                break;\n            case \"doubletap\":\n                if (this.time < this.settings.timeTreshold.hold) {\n                    this.setTimeoutForEvent(this.settings.callbacks.doubletap, this.settings.timeTreshold.tap, this.dataClone);\n                } else {\n                    this.eventCallback(this.settings.callbacks.tapHold, this.dataClone);\n                }\n                break;\n            default:\n                this.data.last.action = null;\n        }\n    }\n\n    /**\n     * handles cross-browser and -device end-event\n     * @param  {Object} event - jQuery-Event-Object\n     * @return {Boolean} always returns false\n     */\n    endHandler(event) {\n\n        const e = this.preHandle(event);\n\n        this.data.time.end = event.timeStamp;\n\n        this.clearTimeouts(this.data.timeout.hold);\n\n        this.data = $.extend(true, this.data, this.calculateEnd(e));\n\n        // called only when not moved\n        if (!this.data.moved && this.data.down && !this.data.multitouch) {\n            this.takeActionEnd(this.data.last.action);\n        }\n        // if was moved\n        else if (this.data.moved && this.data.down && !this.data.multitouch) {\n            if (this.settings.callbacks.swipe || this.settings.callbacks.flick) {\n                this.handleSwipeAndFlick();\n            }\n            this.data.last.action = null;\n        }\n        this.pinchBalance();\n        this.handleMultitouchEnd(e);\n        this.data.last.position = null;\n        return false;\n    }\n\n    /**\n     * handles flick and swipe events\n     * @return {Interact} instance of Interact for chaining\n     */\n    handleSwipeAndFlick() {\n        const direction = this.data.position.end.clone.substract(this.data.last.position);\n\n        const vLDirection = direction.length,\n              directionNormalized = direction.divide(vLDirection, vLDirection);\n\n        if (this.settings.callbacks.swipe && this.time <= this.settings.timeTreshold.swipe) {\n            const originalStart = this.getAbsolutePosition(this.data.position.start);\n            const originalEnd = this.getAbsolutePosition(this.data.position.end);\n            if (originalEnd.distance(originalStart) >= this.settings.distanceTreshold.swipe) {\n                this.data.directions = this.getSwipeDirections(directionNormalized);\n                this.eventCallback(this.settings.callbacks.swipe, this.dataClone);\n            }\n        }\n\n        if (this.settings.callbacks.flick && (this.timeToLastMove <= this.settings.timeTreshold.flick)) {\n            const distance = this.data.last.position.distance(this.data.position.end);\n            this.data.distance = distance;\n            const direction = this.data.last.position.clone.substract(this.data.position.end);\n            this.data.directions = [direction.x, direction.y];\n            this.data.speed = this.calculateSpeed(distance, this.time);\n            if (this.data.speed >= this.settings.speedThreshold) {\n                this.eventCallback(this.settings.callbacks.flick, this.dataClone);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * handles multitouch for end\n     * @param  {e} e - jQuery-Event-Object\n     * @return {Interact} instance of Interact for chaining\n     */\n    handleMultitouchEnd(e) {\n        this.data.multitouch = false;\n        this.data.down = false;\n        this.data.moved = false;\n\n        // if is pointerEvent\n        if (this.isPointerEvent(e)) {\n            if (Object.keys(this.data.pointerArray).length > 1) {\n                this.data.multitouch = true;\n            } else if (Object.keys(this.data.pointerArray).length > 0) {\n                this.data.down = true;\n            }\n        } // touch is used\n        else {\n            if (e.length > 1) {\n                this.data.multitouch = true;\n            } else if (e.length > 0) {\n                this.data.down = true;\n            }\n            this.data.position.move = null;\n        }\n        return this;\n    }\n\n    /**\n     * balances pinching after release of finger\n     * @return {Interact} instance of Interact for chaining\n     */\n    pinchBalance() {\n        if (this.data.multitouch) {\n            this.data.pinched = true;\n            setTimeout((function() {\n                this.data.pinched = false;\n                this.data.last.distance = null;\n            }).bind(this), this.settings.pinchBalanceTime);\n        }\n        return this;\n    }\n\n    /**\n     * calculates the speed with specified distance and time\n     * @param  {number} distance - the specified distance\n     * @param  {number} time - the specified time elapsed\n     * @return {number} the calculated speed\n     */\n    calculateSpeed(distance, time) {\n        return (distance / (time || 0.00001)) * 100;\n    }\n\n    /**\n     * Returns an array of strings, representing the directions\n     * @param  {Point} direction - the specified direction in pixel\n     * @return {string[]} returns an array representing the directions as strings\n     */\n    getSwipeDirections(direction) {\n        return [(direction.x < 0) ? \"left\" : (direction.x > 0) ? \"right\" : \"none\", (direction.y < 0) ? \"up\" : (direction.y > 0) ? \"down\" : \"none\"];\n    }\n\n    /**\n     * Helper for setting a timeout for events\n     * @param {Function} callback - function to be called\n     * @param {number} timeout - time in milliseconds\n     * @param {Object[]} args - array of arguments\n     * @param {Boolean} holdTimeout - if true, a different variable will be used\n     * @return {Interact} Returns this instance\n     */\n    setTimeoutForEvent(callback, timeout, args, holdTimeout) {\n        if (holdTimeout) {\n            this.data.timeout.hold = setTimeout(this.eventCallback.bind(this, callback, args), timeout);\n        } else {\n            this.data.timeout.default = setTimeout(this.eventCallback.bind(this, callback, args), timeout);\n        }\n        return this;\n    }\n\n    /**\n     * Eventhandler for handling the callbacks\n     * @param  {Function} callback - function to be called\n     * @param  {object[]} args - arguments for the function\n     * @return {Interact} Returns this instance\n     */\n    eventCallback(callback, args) {\n        if (callback && typeof callback === \"function\") callback(args);\n        this.data.last.action = null;\n        return this;\n    }\n\n    /**\n     * get the relative position of clientX and clientY\n     * @param  {Object} e - event object\n     * @return {Point} calculated relative position\n     */\n    getRelativePosition(e) {\n        const clientBounds = this.container.getBoundingClientRect(),\n            pos = new Point(e.clientX, e.clientY),\n            bounds = new Point(clientBounds.left, clientBounds.top);\n        return pos.substract(bounds).divide(clientBounds.width, clientBounds.height);\n    }\n\n    /**\n     * get the absolute position of clientX and clientY\n     * @param  {Object} e - event object\n     * @return {Point} calculated absolute position\n     */\n    getAbsolutePosition(point) {\n        const clientBounds = this.container.getBoundingClientRect();\n        return point.mult(clientBounds.width, clientBounds.height);\n    }\n\n    /**\n     * get scroll direction from event\n     * @param  {Object} event - event object\n     * @return {string[]} an array with scroll directions\n     */\n    getScrollDirection(event) {\n        const axis = parseInt(event.axis, 10);\n        const direction = [];\n        if (this.isDownDirection(axis, event)) direction.push(\"down\"); // down\n        else if (this.isUpDirection(axis, event)) direction.push(\"up\"); // up\n        if (this.isRightDirection(axis, event)) direction.push(\"right\"); // right\n        else if (this.isLeftDirection(axis, event)) direction.push(\"left\"); // left\n        return direction;\n    }\n\n    /**\n     * checks if direction is down\n     * @param  {number} axis - what axis is used\n     * @param  {Object} event - Vanilla JS event\n     * @return {Boolean} Whether or not direction is down\n     */\n    isDownDirection(axis, event) {\n        return event.deltaY > 0 || (!event.deltaY && event.wheelDeltaY < 0) || ((axis === 2) && (event.detail > 0)) || (Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail))) < 0);\n    }\n\n    /**\n     * checks if direction is up\n     * @param  {number} axis - what axis is used\n     * @param  {Object} event - Vanilla JS event\n     * @return {Boolean} Whether or not direction is up\n     */\n    isUpDirection(axis, event) {\n        return event.deltaY < 0 || (!event.deltaY && event.wheelDeltaY > 0) || (axis === 2 && event.detail < 0) || (Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail))) > 0);\n    }\n\n    /**\n     * checks if direction is right\n     * @param  {number} axis - what axis is used\n     * @param  {Object} event - Vanilla JS event\n     * @return {Boolean} Whether or not direction is right\n     */\n    isRightDirection(axis, event) {\n        return event.deltaX > 0 || (!event.deltaX && event.wheelDeltaX > 0) || (axis === 1 && event.detail > 0);\n    }\n\n    /**\n     * checks if direction is left\n     * @param  {number} axis - what axis is used\n     * @param  {Object} event - Vanilla JS event\n     * @return {Boolean} Whether or not direction is left\n     */\n    isLeftDirection(axis, event) {\n        return event.deltaX < 0 || (!event.deltaX && event.wheelDeltaX < 0) || (axis === 1 && event.detail < 0);\n    }\n\n    /**\n     * Get event helper, applies jQuery-event-fix too\n     * @param  {Object} e - event object\n     * @return {Object} new fixed and optimized event\n     */\n    getEvent(e) {\n        jQuery.event.fix(e);\n        if (e.originalEvent.touches && e.originalEvent.touches.length === 0) {\n            return e.originalEvent.changedTouches || e.originalEvent;\n        }\n        return e.originalEvent.touches || e.originalEvent.changedTouches || e.originalEvent;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Interact.js\n **/"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtCA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAMA;AACA;;;;;;;;;;;AAUA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAtBA;AAJA;AA6BA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAzBA;AA2BA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;ACrUA;;;;;;;;;;;;;;;;;ACMA;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;;;;;;;;AAOA;AAAA;AAAA;;;;;;;AAOA;AAAA;AAAA;AACA;;;;;;;AAOA;AAAA;AAAA;AACA;;;;;;;AAOA;AAAA;AAAA;AACA;;;;;;;AAOA;AAAA;AAAA;AAzGA;;;;;;;;;;;;;;;;;ACAA;;;;;;;;AAQA;AACA;AACA;AAFA;;;;;;;AAUA;AACA;AADA;;;;;;;;;AAWA;AACA;AACA;AACA;AAHA;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AALA;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AADA;AArEA;;;;;;;;;;;;;;;ACNA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAMA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;;;;;;;;;;;;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAbA;AAkBA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AADA;AAFA;AAMA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AAGA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9SA;AACA;;;;;;;AAKA;AACA;;;;;;;AAMA;AACA;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAQA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9EA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC/FA;AACA;;;;;;;;;;;;;;AAOA;;;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;;;;;;;;;;;;;AASA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;ACvTA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;;;;;;;;;;;;;AASA;AAAA;AAAA;;;;;;;;;;;;;;;AClJA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AAMA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AAkBA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AAGA;AACA;;;;;;;;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;;;;;;;;;;;AAQA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1WA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;;;;;;;;;;;;;AASA;AAAA;AAAA;;;;;;;;;;;;;;;ACzGA;AACA;;;;;;;;;AAMA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAKA;AACA;;;;;;;;AAYA;;;;;;;;;;;;;;AAYA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1FA;AACA;;;;;;;;;AAMA;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AACA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAiBA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AADA;AAGA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAcA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;AC/EA;AACA;;;AAAA;AACA;;;;;;;;;;;AAMA;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzEA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAMA;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AADA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;;;;;AAIA;;;;;;;;;;;;;AC/GA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AAOA;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtDA;AACA;;;;;AA4DA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AAfA;;;;;AAqBA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAJA;AAPA;;;;;;;;;;;;;;;;;AC9FA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAMA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAKA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACxLA;;;;;;;;;;;;;;;;;;ACCA;AACA;;;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAMA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAoBA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AAjBA;AAmBA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAFA;AA1BA;AA+BA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AAKA;AACA;AACA;;;;;;;;AAKA;AACA;AAKA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;;AASA;AACA;AACA;;AAEA;AACA;AACA;AAFA;;AAIA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAHA;AAOA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AADA;AADA;AAKA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AALA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AALA;AAOA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AALA;AAOA;AACA;;;;;;;;;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AADA;AADA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AADA;AADA;AAKA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;","sourceRoot":""}