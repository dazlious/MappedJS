{"version":3,"file":"mappedJS.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap f1e56967c9b7f303abc4","webpack:///plugin/src/js/Main.js","webpack:///external \"jQuery\"","webpack:///plugin/src/js/TileMap.js","webpack:///plugin/src/js/View.js","webpack:///plugin/src/js/Point.js","webpack:///plugin/src/js/LatLng.js","webpack:///plugin/src/js/Bounds.js","webpack:///plugin/src/js/Rectangle.js","webpack:///plugin/src/js/Tile.js","webpack:///plugin/src/js/StateHandler.js","webpack:///plugin/src/js/Helper.js","webpack:///plugin/src/js/Marker.js","webpack:///plugin/src/js/DataEnrichment.js","webpack:///plugin/src/js/Interact.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jQuery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jQuery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"de\"] = factory(require(\"jQuery\"));\n\telse\n\t\troot[\"de\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f1e56967c9b7f303abc4\n **/","import $ from 'jQuery';\nimport {TileMap} from './TileMap.js';\nimport {DataEnrichment} from './DataEnrichment.js';\nimport {Helper} from './Helper.js';\nimport {Interact} from './Interact.js';\nimport {LatLng} from './LatLng.js';\nimport {Point} from './Point.js';\n\nexport class MappedJS {\n\n    /**\n     * Constructor\n     * @param  {string|Object} container=\".mjs\" - Container, either string, jQuery-object or dom-object\n     * @param  {string|Object} mapData={} - data of map tiles, can be json or path to file\n     * @param  {Object} mapSettings={} - settings for map, must be json\n     * @param  {Object} events={loaded: \"mjs-loaded\"} - List of events\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    constructor({container=\".mjs\", mapData={}, mapSettings={}, events={loaded:\"mjs-loaded\"}, debug = false}) {\n        this.initializeSettings(container, events, mapSettings);\n\n        this.initializeData(mapData, function() {\n            this.initializeMap();\n            this.addControls();\n            this.bindEvents();\n            this.loadingFinished();\n        }.bind(this));\n\n        this.momentum = null;\n        this.keyTicks = 0;\n\n        this.debug = debug;\n\n        return this;\n    }\n\n    addControls() {\n        if (this.mapSettings.controls) {\n            this.$controls = $(`<div class=\"control-container ${this.mapSettings.controls.theme} ${this.mapSettings.controls.position}\" />`);\n            this.$zoomIn = $(\"<div class='control zoom-in' />\");\n            this.$zoomOut = $(\"<div class='control zoom-out' />\");\n            this.$home = $(\"<div class='control home' />\");\n            this.$controls.append(this.$home).append(this.$zoomIn).append(this.$zoomOut);\n            this.$container.append(this.$controls);\n        }\n    }\n\n    /**\n     * initializes the settings and handles errors\n     * @param  {string|Object} container - Container, either string, jQuery-object or dom-object\n     * @param  {object} events - List of events\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    initializeSettings(container, events, settings) {\n        this.$container = (typeof container === \"string\") ? $(container) : ((typeof container === \"object\" && container instanceof jQuery) ? container : $(container));\n        if (!(this.$container instanceof jQuery)) {\n            throw new Error(\"Container \" + container + \" not found\");\n        }\n        this.$container.addClass(\"mappedJS\");\n\n        this.mapSettings = DataEnrichment.mapSettings(settings);\n\n        this.events = events;\n\n        return this;\n    }\n\n    /**\n     * initializes the data, asynchronous\n     * @param  {Object} mapData - data of map tiles, can be json or path to file\n     * @param  {Function} cb - called, when data is received\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    initializeData(mapData, cb) {\n        const _this = this;\n        if (typeof mapData === \"string\") {\n            Helper.requestJSON(mapData, function(data) {\n                _this.mapData = data;\n                cb();\n            });\n        } else {\n            this.mapData = (typeof mapData === \"object\") ? mapData : null;\n            cb();\n        }\n        return this;\n    }\n\n    /**\n     * initializes Map module\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    initializeMap() {\n        this.tileMap = new TileMap({\n            container: this.$container,\n            tilesData: this.mapData,\n            settings: this.mapSettings,\n            debug: this.debug\n        });\n        return this;\n    }\n\n    /**\n     * get absolute position of a point\n     * @param  {Point} point - specified relative position\n     * @return {Point} absolute position to viewport\n     */\n    getAbsolutePosition(point) {\n        return point.clone.multiply(this.tileMap.view.viewport.width, this.tileMap.view.viewport.height);\n    }\n\n    initializeInteractForMap() {\n        this.interact = new Interact({\n            container: this.$container,\n            autoFireHold: 300,\n            overwriteViewportSettings: true,\n            callbacks: {\n                pan: function(data) {\n                    if ($(data.target).hasClass(\"control\")) {\n                        return false;\n                    }\n                    const change = data.last.position.clone.substract(data.position.move);\n                    this.moveView(this.getAbsolutePosition(change).multiply(-1, -1));\n                }.bind(this),\n                wheel: function(data) {\n                    const factor = data.zoom / 10;\n                    this.zoom(factor, this.getAbsolutePosition(data.position.start));\n                }.bind(this),\n                pinch: function(data) {\n                    this.zoom(data.difference * 3, this.getAbsolutePosition(data.position.move));\n                }.bind(this),\n                doubletap: function(data) {\n                    if ($(data.target).hasClass(\"control\")) {\n                        return false;\n                    }\n                    this.zoom(0.2, this.getAbsolutePosition(data.position.start));\n                }.bind(this),\n                flick: function(data) {\n                    const direction = new Point(data.directions[0], data.directions[1]),\n                          velocity = direction.clone.divide(data.speed).multiply(20);\n                    this.momentumAccerlation(velocity);\n\n                }.bind(this)\n            }\n        });\n    }\n\n    /**\n     * binds all events to handlers\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    bindEvents() {\n\n        this.initializeInteractForMap();\n\n        $(window).on(\"resize orientationchange\", this.resizeHandler.bind(this));\n\n        $(document).on(\"keydown\", this.keyPress.bind(this));\n        $(document).on(\"keyup\", this.keyRelease.bind(this));\n\n        const gesture = Helper.isTouch() ? \"touchstart\": \"mousedown\";\n\n        this.$zoomIn.on(gesture, this.zoomInToCenter.bind(this));\n        this.$zoomOut.on(gesture, this.zoomOutToCenter.bind(this));\n        this.$home.on(gesture, this.resetToInitialState.bind(this));\n\n        return this;\n    }\n\n    resetToInitialState() {\n        this.tileMap.view.reset();\n        this.tileMap.view.drawIsNeeded = true;\n    }\n\n    zoomInToCenter() {\n        this.zoom(0.1, this.tileMap.view.viewport.center);\n    }\n\n    zoomOutToCenter() {\n        this.zoom(-0.1, this.tileMap.view.viewport.center);\n    }\n\n    keyPress(e) {\n        console.log(e.keyCode);\n        switch(e.keyCode) {\n            case 38: // up\n                this.handleMovementByKeys(new Point(0, 1));\n                break;\n            case 37: // left\n                this.handleMovementByKeys(new Point(1, 0));\n                break;\n            case 39: // right\n                this.handleMovementByKeys(new Point(-1, 0));\n                break;\n            case 40: // down\n                this.handleMovementByKeys(new Point(0, -1));\n                break;\n            case 187: // plus\n                this.zoomInToCenter();\n                break;\n            case 107: // plus numpad\n                this.zoomInToCenter();\n                break;\n            case 189: // minus\n                this.zoomOutToCenter();\n                break;\n            case 109: // minus numpad\n                this.zoomOutToCenter();\n                break;\n            case 72: // home\n                this.resetToInitialState();\n                break;\n            default:\n                break;\n        }\n        this.tileMap.view.drawIsNeeded = true;\n    }\n\n    handleMovementByKeys(direction) {\n        this.keyTicks++;\n        this.tileMap.view.moveView(direction.multiply(this.keyTicks));\n    }\n\n    keyRelease() {\n        this.keyTicks = 0;\n    }\n\n    /**\n     * momentum flicking\n     * @param  {number} velocity - speed\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    momentumAccerlation(velocity) {\n        this.maxMomentumSteps = 30;\n        this.triggerMomentum(this.maxMomentumSteps, 10, velocity.multiply(-1));\n        return this;\n    }\n\n    /**\n     * recursive momentum handler\n     * @param  {number} steps - current step (decreasing)\n     * @param  {number} timing - time for step\n     * @param  {Point} change - distance\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    triggerMomentum(steps, timing, change) {\n        this.momentum = setTimeout(function() {\n            steps--;\n            const delta = Helper.easeOutQuadratic((this.maxMomentumSteps - steps) * timing, change, change.clone.multiply(-1), timing * this.maxMomentumSteps);\n            this.moveView(delta);\n            if (steps >= 0) {\n                this.triggerMomentum(steps, timing, change);\n            }\n        }.bind(this), timing);\n        return this;\n    }\n\n    /**\n     * move by delta momentum\n     * @param  {Point} delta - delta of x/y\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    moveView(delta) {\n        this.tileMap.view.moveView(delta);\n        this.tileMap.view.drawIsNeeded = true;\n        return this;\n    }\n\n    /**\n     * handles zoom by factor and position\n     * @param  {number} factor - difference in zoom scale\n     * @param  {Point} position - position to zoom to\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    zoom(factor, position) {\n        if (factor !== 0) {\n            this.tileMap.view.zoom(factor, position);\n            this.tileMap.view.drawIsNeeded = true;\n        }\n        return this;\n    }\n\n    /**\n     * handles resizing of window\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    resizeHandler() {\n        this.tileMap.resize();\n        return this;\n    }\n\n    /**\n     * called when loading and initialization is finished\n     * @return {MappedJS} instance of MappedJS for chaining\n     */\n    loadingFinished() {\n        this.$container.trigger(this.events.loaded);\n        return this;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Main.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jQuery\"\n ** module id = 1\n ** module chunks = 0\n **/","import $ from 'jQuery';\nimport {View} from './View.js';\nimport {LatLng} from './LatLng.js';\nimport {Bounds} from './Bounds.js';\nimport {Rectangle} from './Rectangle.js';\n\nexport class TileMap {\n\n    /**\n     * Returns left offset of container\n     * @return {number} - left offset of container\n     */\n    get left() {\n        return this.$container.offset().left;\n    }\n\n    /**\n     * Returns top offset of container\n     * @return {number} - top offset of container\n     */\n    get top() {\n        return this.$container.offset().top;\n    }\n\n    /**\n     * Returns width of container\n     * @return {number} - width of container\n     */\n    get width() {\n        return this.$container.innerWidth();\n    }\n\n    /**\n     * Returns height of container\n     * @return {number} - height of container\n     */\n    get height() {\n        return this.$container.innerHeight();\n    }\n\n    /** Constructor\n     * @param  {Object} container - jQuery-object holding the container\n     * @param  {Object} tilesData={} - json object representing data of TileMap\n     * @param  {Object} settings={} - json object representing settings of TileMap\n     * @param  {Boolean} debug=false - Option for enabling debug-mode\n     * @return {TileMap} instance of TileMap\n     */\n    constructor({container, tilesData = {}, settings = {}, debug = false}) {\n        if (!container) {\n            throw Error(\"You must define a container to initialize a TileMap\");\n        }\n\n        this.$container = container;\n        this.imgData = tilesData[TileMap.IMG_DATA_NAME];\n        this.markerData = tilesData[TileMap.MARKER_DATA_NAME];\n        this.settings = settings;\n\n        this.debug = debug;\n\n        this.initialize(settings.bounds, settings.center, this.getCurrentLevelData());\n\n        return this;\n    }\n\n    /**\n     * initializes the TileMap\n     * @return {TileMap} instance of TileMap\n     */\n    initialize(bounds, center, data) {\n        this.initializeCanvas();\n        this.view = new View({\n            viewport: new Rectangle(this.left, this.top, this.width, this.height),\n            mapView: new Rectangle(0, 0, data.dimensions.width, data.dimensions.height),\n            bounds: bounds,\n            center: center,\n            data: data,\n            maxZoom: data.zoom.max,\n            minZoom: data.zoom.min,\n            markerData: this.markerData,\n            $container: this.$container,\n            context: this.canvasContext,\n            debug: this.debug\n        });\n        this.resizeCanvas();\n        return this;\n    }\n\n    /**\n     * initializes the canvas, adds to DOM\n     * @return {TileMap} instance of TileMap\n     */\n    initializeCanvas() {\n        this.$canvas = $(\"<canvas class='mjs-canvas' />\");\n        this.canvas = this.$canvas[0];\n        this.$container.append(this.$canvas);\n        this.canvasContext = this.canvas.getContext(\"2d\");\n        return this;\n    }\n\n    /**\n     * gets data of current zoom level\n     * @return {Object} data for current level as json\n     */\n    getCurrentLevelData() {\n        return this.imgData[\"level-\" + this.settings.level];\n    }\n\n    /**\n     * clears canvas\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    clearCanvas() {\n        this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        return this;\n    }\n\n    /**\n     * complete clear and draw of all visible tiles\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    redraw() {\n        this.clearCanvas();\n        this.view.drawIsNeeded = true;\n        return this;\n    }\n\n    /**\n     * Handles resizing of TileMap\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    resize() {\n        this.resizeCanvas();\n        this.resizeView();\n        this.redraw();\n        return this;\n    }\n\n    /**\n     * resizes the canvas sizes\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    resizeCanvas() {\n        this.canvasContext.canvas.width = this.width;\n        this.canvasContext.canvas.height = this.height;\n        return this;\n    }\n\n    /**\n     * Handles resizing of view\n     * @return {TileMap} instance of TileMap for chaining\n     */\n    resizeView() {\n        const oldViewport = this.view.viewport.clone;\n        this.view.viewport.size(this.left, this.top, this.width, this.height);\n        const difference = this.view.viewport.center.substract(oldViewport.center);\n        this.view.mapView.translate(difference.x, difference.y);\n        return this;\n    }\n\n}\n\n/**\n * name of image data in data.json\n * @type {String}\n */\nTileMap.IMG_DATA_NAME = \"img_data\";\n\n/**\n * name of marker data in data.json\n * @type {String}\n */\nTileMap.MARKER_DATA_NAME = \"marker\";\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/TileMap.js\n **/","import $ from 'jQuery';\nimport {Point} from './Point.js';\nimport {LatLng} from './LatLng.js';\nimport {Bounds} from './Bounds.js';\nimport {Rectangle} from './Rectangle.js';\nimport {Tile} from './Tile.js';\nimport {Marker} from './Marker.js';\nimport {Helper} from './Helper.js';\nimport {DataEnrichment} from './DataEnrichment.js';\n\nexport class View {\n\n    /**\n     * Returns current distortionFactor\n     * @return {number} returns current distortionFactor of latitude\n     */\n    get distortionFactor() {\n        return this.getDistortionFactorForLatitude(this.center);\n    }\n\n    /**\n     * Returns the current distorted viewport\n     */\n    get offsetToCenter() {\n        return (this.viewport.width - this.viewport.width * this.distortionFactor) / 2;\n    }\n\n    get currentView() {\n        return this.mapView;\n    }\n\n    /**\n     * get all visible tiles\n     * @return {array} all tiles that are currently visible\n     */\n    get visibleTiles() {\n        return this.tiles.filter(function(t) {\n            const newTile = t.clone.scale(this.zoomFactor, this.zoomFactor).getDistortedRect(this.distortionFactor).translate(this.currentView.x * this.distortionFactor + this.offsetToCenter, this.currentView.y);\n            return this.viewport.intersects(newTile);\n        }, this);\n    }\n\n    /**\n     * how many pixels per lat and lng\n     * @return {Point} pixels per lat/lng\n     */\n    get pixelPerLatLng() {\n        return new Point(this.currentView.width / this.bounds.width, this.currentView.height / this.bounds.height);\n    }\n\n    /**\n     * Constructor\n     * @param  {Rectangle} viewport = new Rectangle() - current representation of viewport\n     * @param  {Rectangle} mapView = new Rectangle() - current representation of map\n     * @param  {Bounds} bounds = new Bounds() - current bounds of map\n     * @param  {LatLng} center = new LatLng() - current center of map\n     * @param  {Object} data = {} - tile data of current map\n     * @param  {Object} markerData = {} - marker data of current map\n     * @param  {Object} $container = null - parent container for markers\n     * @param  {Object} context = null - canvas context for drawing\n     * @param  {number} maxZoom = 1.5 - maximal zoom of view\n     * @param  {number} minZoom = 0.8 - minimal zoom of view\n     * @param  {Boolean} debug=false - Option for enabling debug-mode\n     * @return {View} instance of View for chaining\n     */\n    constructor({\n        viewport = new Rectangle(),\n        mapView = new Rectangle(),\n        bounds = new Bounds(),\n        center = new LatLng(),\n        data = {},\n        markerData = null,\n        $container = null,\n        context = null,\n        maxZoom = 1.5,\n        minZoom = 0.8,\n        debug = false\n        }) {\n\n        this.mapView = mapView;\n        this.originalMapView = mapView.clone;\n        this.viewport = viewport;\n        this.bounds = bounds;\n        this.center = center;\n        this.zoomFactor = 1;\n        this.maxZoom = maxZoom;\n        this.minZoom = minZoom;\n        this.origin = new Point(0,0);\n        this.debug = debug;\n        this.lastDraw = new Date();\n\n        if (this.debug) {\n            this.$debugContainer = $(\"<div class='debug'></div>\");\n            this.$debugContainer.css({\n                \"position\": \"absolute\",\n                \"width\": \"100%\",\n                \"height\": \"20px\",\n                \"top\": 0,\n                \"right\": 0,\n                \"background\": \"rgba(0,0,0,.6)\",\n                \"color\": \"#fff\",\n                \"text-align\": \"right\",\n                \"padding-right\": \"10px\"\n            });\n            $container.prepend(this.$debugContainer);\n        }\n\n        const newCenter = this.viewport.center.substract(this.convertLatLngToPoint(center));\n        this.currentView.position(newCenter.x, newCenter.y);\n\n        this.tiles = [];\n        this.data = data;\n        this.context = context;\n        this.markers = [];\n\n        this.initial = {\n            position: this.center,\n            zoom: this.zoomFactor\n        };\n\n        this.drawIsNeeded = true;\n\n        this.initializeTiles().loadThumb().initializeMarkers(markerData, $container);\n\n        return this;\n    }\n\n    // TODO: Reset function not working properly\n    reset() {\n        this.setLatLngToPosition(this.initial.position, this.viewport.center);\n        const delta = this.initial.zoom - this.zoomFactor;\n        this.zoom(delta, this.viewport.center);\n    }\n\n    /**\n     * main draw call\n     */\n    mainLoop() {\n        if (this.debug && this.drawIsNeeded) {\n            const now = new Date();\n            const fps = (1000 / (now - this.lastDraw)).toFixed(2);\n            this.lastDraw = now;\n            this.$debugContainer.text(`FPS: ${fps}`);\n        }\n\n        if (this.drawIsNeeded) {\n            this.drawIsNeeded = false;\n            this.context.clearRect(0, 0, this.viewport.width, this.viewport.height);\n            this.draw();\n        }\n\n        window.requestAnimFrame(this.mainLoop.bind(this));\n    }\n\n    /**\n     * loads thumbnail of view\n     * @return {View} instance of View for chaining\n     */\n    loadThumb() {\n        Helper.loadImage(this.data.thumb, function(img) {\n            this.thumb = img;\n            window.requestAnimFrame(this.mainLoop.bind(this));\n        }.bind(this));\n        return this;\n    }\n\n    /**\n     * converts a Point to LatLng in view\n     * @param  {Point} point - specified point to be converted\n     * @return {LatLng} presentation of point in lat-lng system\n     */\n    convertPointToLatLng(point) {\n        point.divide(this.pixelPerLatLng.x, this.pixelPerLatLng.y);\n        return new LatLng(this.bounds.nw.lat - point.y, point.x + this.bounds.nw.lng).multiply(-1);\n    }\n\n    /**\n     * set specified lat/lng to position x/y\n     * @param {LatLng} latlng - specified latlng to be set Point to\n     * @param {Point} position - specified position to set LatLng to\n     * @return {View} instance of View for chaining\n     */\n    setLatLngToPosition(latlng, position) {\n        const currentPosition = this.currentView.topLeft.substract(position).multiply(-1),\n              diff = currentPosition.substract(this.convertLatLngToPoint(latlng));\n\n        this.currentView.translate(0, diff.y);\n        this.calculateNewCenter();\n        this.currentView.translate(diff.x + this.getDeltaXToCenter(position), 0);\n        return this;\n    }\n\n    /**\n     * converts a LatLng to Point in view\n     * @param  {LatLng} latlng - specified latlng to be converted\n     * @return {Point} presentation of point in pixel system\n     */\n    convertLatLngToPoint(latlng) {\n        const relativePosition = this.bounds.nw.clone.substract(latlng);\n        relativePosition.multiply(this.pixelPerLatLng.y, this.pixelPerLatLng.x);\n        return new Point(relativePosition.lng, relativePosition.lat).abs;\n    }\n\n    /**\n     * receive relative Position to center of viewport\n     * @param  {Point} pos - specified position\n     * @return {number} delta of point to center of viewport\n     */\n    getDeltaXToCenter(pos) {\n        const diffToCenter = pos.clone.substract(this.viewport.center);\n        const distanceToCenter = (diffToCenter.x / this.viewport.center.x);\n        const delta = distanceToCenter * this.offsetToCenter;\n        return delta / this.distortionFactor;\n    }\n\n    /**\n     * zooming handler\n     * @param  {number} factor - increase/decrease factor\n     * @param  {Point} pos - Position to zoom to\n     * @return {View} instance of View for chaining\n     */\n    zoom(factor, pos) {\n        this.zoomFactor = Math.max(Math.min(this.zoomFactor + factor, this.maxZoom), this.minZoom);\n        const mapPosition = this.currentView.topLeft.substract(pos).multiply(-1);\n        mapPosition.x += this.getDeltaXToCenter(pos);\n        const latlngPosition = this.convertPointToLatLng(mapPosition).multiply(-1);\n\n        const newSize = this.originalMapView.clone.scale(this.zoomFactor);\n        this.currentView.setSize(newSize.width, newSize.height);\n\n        this.setLatLngToPosition(latlngPosition, pos);\n        this.moveView(new Point());\n        return this;\n    }\n\n    /**\n     * get distortion factor for specified latitude\n     * @param  {LatLng} latlng - lat/lng position\n     * @return {number} distortion factor\n     */\n    getDistortionFactorForLatitude(latlng) {\n         return (Math.cos(Helper.toRadians(latlng.lat)));\n    }\n\n    /**\n     * update center position of view\n     * @return {View} instance of View for chaining\n     */\n    calculateNewCenter() {\n        const newCenter = this.viewport.center.substract(this.currentView.topLeft);\n        this.center = this.convertPointToLatLng(newCenter);\n        return this;\n    }\n\n    /**\n     * moves the view's current position by pos\n     * @param  {Point} pos - specified additional offset\n     * @return {View} instance of View for chaining\n     */\n    moveView(pos) {\n        pos.divide(this.distortionFactor, 1);\n        const equalizedMap = this.currentView.getDistortedRect(this.distortionFactor).translate(this.offsetToCenter + pos.x, pos.y);\n        if (!equalizedMap.containsRect(this.viewport)) {\n            if (equalizedMap.width >= this.viewport.width) {\n                if (equalizedMap.left - this.viewport.left > 0) {\n                    pos.x -= (equalizedMap.left - this.viewport.left);\n                }\n                if (equalizedMap.right - this.viewport.right < 0) {\n                    pos.x -= (equalizedMap.right - this.viewport.right);\n                }\n            } else {\n                this.currentView.setCenterX(this.viewport.center.x);\n                pos.x = 0;\n            }\n\n            if (equalizedMap.height >= this.viewport.height) {\n                if (equalizedMap.top - this.viewport.top > 0) {\n                    pos.y -= (equalizedMap.top - this.viewport.top);\n                }\n                if (equalizedMap.bottom - this.viewport.bottom < 0) {\n                    pos.y -= (equalizedMap.bottom - this.viewport.bottom);\n                }\n            } else {\n                this.currentView.setCenterY(this.viewport.center.y);\n                pos.y = 0;\n            }\n        }\n\n        this.currentView.translate(pos.x, pos.y);\n\n        this.calculateNewCenter();\n\n        return this;\n    }\n\n    /**\n     * Handles draw of visible elements\n     * @return {View} instance of View for chaining\n     */\n    draw() {\n        this.drawThumbnail();\n        this.repositionMarkerContainer();\n        this.drawVisibleTiles();\n        return this;\n    }\n\n    /**\n     * draws all visible tiles\n     * @return {View} instance of View for chaining\n     */\n    drawVisibleTiles() {\n        Helper.forEach(this.visibleTiles, function(tile) {\n            tile.draw();\n        }.bind(this));\n        return this;\n    }\n\n    /**\n     * draws the thumbnail\n     * @return {View} instance of View for chaining\n     */\n    drawThumbnail() {\n        const rect = this.currentView.getDistortedRect(this.distortionFactor).translate(this.offsetToCenter, 0);\n        this.context.drawImage(this.thumb, 0, 0, this.thumb.width, this.thumb.height, rect.x, rect.y, rect.width, rect.height);\n        return this;\n    }\n\n    /**\n     * initializes tiles\n     * @return {View} instance of View for chaining\n     */\n    initializeTiles() {\n        const currentLevel = this.data.tiles;\n        Helper.forEach(currentLevel, function(currentTileData) {\n            const currentTile = new Tile(currentTileData, this);\n            this.tiles.push(currentTile);\n        }.bind(this));\n        return this;\n    }\n\n    /**\n     * append marker container to DOM\n     * @param  {Object} $container - jQuery-selector\n     * @return {View} instance of View for chaining\n     */\n    appendMarkerContainerToDom($container) {\n        this.$markerContainer = $(\"<div class='marker-container' />\");\n        $container.append(this.$markerContainer);\n        return this;\n    }\n\n    /**\n     * enrich marker data\n     * @param  {Object} markerData - data of markers\n     * @param  {Object} $container - jQuery-selector\n     * @return {Object} enriched marker data\n     */\n    enrichMarkerData(markerData, $container) {\n        DataEnrichment.marker(markerData, function(enrichedMarkerData) {\n            this.appendMarkerContainerToDom($container);\n            markerData = enrichedMarkerData;\n        }.bind(this));\n        return markerData;\n    }\n\n    /**\n     * initializes all markers\n     * @param  {Object} markerData - data of all markers\n     * @param  {Object} $container - jQuery-selector\n     * @return {View} instance of View for chaining\n     */\n    initializeMarkers(markerData, $container) {\n        if (markerData) {\n            markerData = this.enrichMarkerData(markerData, $container);\n            Helper.forEach(markerData, function(currentData) {\n                const m = new Marker(currentData, this);\n                this.markers.push(m);\n            }.bind(this));\n        }\n        return this;\n    }\n\n    /**\n     * reposition marker container\n     * @return {View} instance of View for chaining\n     */\n    repositionMarkerContainer() {\n        if (this.$markerContainer) {\n            const newSize = this.currentView.getDistortedRect(this.distortionFactor);\n            this.$markerContainer.css({\n               \"width\": `${newSize.width}px`,\n               \"height\": `${newSize.height}px`,\n               \"left\": `${newSize.left + this.offsetToCenter}px`,\n               \"top\": `${newSize.top}px`\n            });\n        }\n        return this;\n    }\n\n}\n\n/**\n * request animation frame browser polyfill\n * @return {Function} supported requestAnimationFrame-function\n */\nwindow.requestAnimFrame = (function(){\n  return window.requestAnimationFrame       ||\n         window.webkitRequestAnimationFrame ||\n         window.mozRequestAnimationFrame    ||\n         function( callback ){\n             window.setTimeout(callback, 1000 / 60);\n         };\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/View.js\n **/","export class Point {\n\n    /**\n     * length of a point\n     * @return {number} length of a point\n     */\n    get length() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n    }\n\n    /**\n     * gets a clone of this point\n     * @return {Point} new instance equals this point\n     */\n    get clone() {\n        return Point.createFromPoint(this);\n    }\n\n    /**\n     * gets absolute Point\n     * @return {Point} returns Point with absolute values\n     */\n    get abs() {\n        return new Point(Math.abs(this.x), Math.abs(this.y));\n    }\n\n    /**\n     * Constructor\n     * @param  {number} x = 0 - representation of x coordinate\n     * @param  {number} y = 0 - representation of y coordinate\n     * @return {Point} new instance of point\n     */\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n\n    /**\n     * substracts 2 points\n     * @param  {Point} point - the point to substract from this\n     * @return {Point} difference between this point and parameter point\n     */\n    substract(point) {\n        this.x -= point.x;\n        this.y -= point.y;\n        return this;\n    }\n\n    /**\n     * adds 2 points\n     * @param  {Point} point - the point to add to this\n     * @return {Point} addition of this point and parameter point\n     */\n    add(point) {\n        this.x += point.x;\n        this.y += point.y;\n        return this;\n    }\n\n    /**\n     * multiplicates a point with a given x and y\n     * @param  {number} x - factor to multiplicate x with\n     * @param  {number} y - factor to multiplicate y with\n     * @return {Point} Returns a new instance\n     */\n    multiply(x, y = x) {\n        this.x *= x;\n        this.y *= y;\n        return this;\n    }\n\n    /**\n     * divide a point with a given x and y\n     * @param  {number} x - factor to divide x with\n     * @param  {number} y - factor to divide y with\n     * @return {Point} Returns a new instance\n     */\n    divide(x, y = x) {\n        this.x /= x;\n        this.y /= y;\n        return this;\n    }\n\n    /**\n     * check if points are equal\n     * @param  {Point} point - the point to check against this\n     * @return {Boolean} is true, if x and y are the same\n     */\n    equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n\n    /**\n     * Returns the distance from this Point to a specified Point\n     * @param  {Point} point - the specified point to be measured against this Point\n     * @return {Point} the distance between this Point and specified point\n     */\n    distance(point) {\n        return this.clone.substract(point).length;\n    }\n\n    /**\n     * translates a point by x and y\n     * @param  {number} x - value to move x\n     * @param  {number} y - value to move y\n     * @return {Point} instance of Point\n     */\n    translate(x, y) {\n        this.x += x;\n        this.y += y;\n        return this;\n    }\n\n    /**\n     * positions a point by x and y\n     * @param  {number} x - value to position x\n     * @param  {number} y - value to position y\n     * @return {Point} instance of Point\n     */\n    position(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n\n    /**\n     * translates a Point to an array\n     * @return {Array} Returns Point as Array(x, y)\n     */\n    toArray() {\n        return [this.x, this.y];\n    }\n\n}\n\n/**\n * Creates a Point from specified point\n * @param  {Point} point - specified point\n * @return {Point} the point specified\n */\nPoint.createFromPoint = (point) => new Point(point.x, point.y);\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Point.js\n **/","export class LatLng {\n\n    /**\n     * length of a latlng\n     * @return {number} length of a latlng\n     */\n    get length() {\n        return Math.sqrt(Math.pow(this.lat, 2) + Math.pow(this.lng, 2));\n    }\n\n    /**\n     * gets a clone of this latlng\n     * @return {LatLng} new instance equals this latlng\n     */\n    get clone() {\n        return LatLng.createFromLatLng(this);\n    }\n\n    /**\n     * Constructor\n     * @param  {number} lat = 0 - representation of latitude\n     * @param  {number} lng = 0 - representation of longitude\n     * @param  {Boolean} isDistance = false - if LatLng should be checked against bounds\n     * @return {LatLng} new instance of LatLng\n     */\n    constructor(lat = 0, lng = 0) {\n        this.lat = lat;\n        this.lng = lng;\n        return this;\n    }\n\n    /**\n     * substract specified coord from this coordinate\n     * @param  {LatLng} coord - specified coordinate to substract from this coord\n     * @return {LatLng} the new calculated LatLng\n     */\n    substract(coord) {\n        this.lat -= coord.lat;\n        this.lng -= coord.lng;\n        return this;\n    }\n\n    /**\n     * add specified coord to this coordinate\n     * @param  {LatLng} coord - specified coordinate to add to this coord\n     * @return {LatLng} the new calculated LatLng\n     */\n    add(coord) {\n        this.lat += coord.lat;\n        this.lng += coord.lng;\n        return this;\n    }\n\n    /**\n    * divides a latlng with a given factor\n    * @param  {number} factorLat - factor to divide lat with\n    * @param  {number} factorLng = factorLat - factor to divide lng with\n     * @return {LatLng} Returns instance for chaining\n     */\n    divide(factorLat, factorLng = factorLat) {\n        this.lat /= factorLat;\n        this.lng /= factorLng;\n        return this;\n    }\n\n    /**\n     * multiplicates a latlng with a given factor\n     * @param  {number} factorLat - factor to multiplicate lat with\n     * @param  {number} factorLng = factorLat - factor to multiplicate lng with\n     * @return {LatLng} Returns instance for chaining\n     */\n    multiply(factorLat, factorLng = factorLat) {\n        this.lat *= factorLat;\n        this.lng *= factorLng;\n        return this;\n    }\n\n    /**\n     * checks if specified coord equals this coord\n     * @param  {LatLng} coord - specified coord to check against\n     * @return {Boolean} Returns if specified coord equals this coord\n     */\n    equals(coord) {\n        return this.lat === coord.lat && this.lng === coord.lng;\n    }\n\n}\n\n/**\n * Creates a LatLng from specified LatLng\n * @param  {LatLng} LatLng - specified LatLng\n * @return {LatLng} the LatLng specified\n */\nLatLng.createFromLatLng = (latlng) => new LatLng(latlng.lat, latlng.lng);\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/LatLng.js\n **/","import {LatLng} from './LatLng.js';\n\nexport class Bounds {\n\n    /**\n     * get width of boundaries\n     * @return {number} width of boundaries\n     */\n    get width() {\n        return Math.abs(this.so.lng - this.nw.lng);\n    }\n\n    /**\n     * get height of boundaries\n     * @return {number} height of boundaries\n     */\n    get height() {\n        return Math.abs(this.so.lat - this.nw.lat);\n    }\n\n    /**\n     * get size\n     * @return {Point} calculated Size of boundaries\n     */\n    get range() {\n        return this.nw.clone.substract(this.so);\n    }\n\n    /**\n     * Constructor\n     * @param  {number} northWest = new LatLng() - representation of northWest boundary\n     * @param  {number} southEast = new LatLng() - representation of southEast boundary\n     * @return {Bounds} instance of Bounds for chaining\n     */\n    constructor(northWest = new LatLng(), southEast = new LatLng()) {\n        if (northWest.lat < southEast.lat || northWest.lng > southEast.lng) {\n            throw new Error(`${northWest} needs to be top-right corner and ${southEast} bottom-left`);\n        }\n        this.nw = northWest;\n        this.so = southEast;\n        return this;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Bounds.js\n **/","import {Point} from './Point.js';\n\nexport class Rectangle extends Point {\n\n    /**\n     * get center-position of rectangle\n     * @return {Point} center point\n     */\n    get center() {\n        return new Point(this.x + (this.width / 2), this.y + (this.height / 2));\n    }\n\n    /**\n     * get top-left-position of rectangle\n     * @return {Point} top-left point\n     */\n    get topLeft() {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * get top-right-position of rectangle\n     * @return {Point} top-right point\n     */\n    get topRight() {\n        return new Point(this.x + this.width, this.y);\n    }\n\n    /**\n     * get bottom-left-position of rectangle\n     * @return {Point} bottom-left point\n     */\n    get bottomLeft() {\n        return new Point(this.x, this.y + this.height);\n    }\n\n    /**\n     * get bottom-right-position of rectangle\n     * @return {Point} bottom-right point\n     */\n    get bottomRight() {\n        return new Point(this.x + this.width, this.y + this.height);\n    }\n\n    /**\n     * Returns right position of Rectangle\n     * @return {number} right position\n     */\n    get right() {\n        return this.x + this.width;\n    }\n\n    /**\n     * Returns left position of Rectangle\n     * @return {number} left position\n     */\n    get left() {\n        return this.x;\n    }\n\n    /**\n     * Returns top position of Rectangle\n     * @return {number} top position\n     */\n    get top() {\n        return this.y;\n    }\n\n    /**\n     * Returns bottom position of Rectangle\n     * @return {number} bottom position\n     */\n    get bottom() {\n        return this.y + this.height;\n    }\n\n    /**\n     * clones a rectangle\n     * @return {Rectangle} duplicated rectangle\n     */\n    get clone() {\n        return Rectangle.createFromRectangle(this);\n    }\n\n    /**\n     * Constructor\n     * @param  {number} x=0 - x-position of specified rectangle\n     * @param  {number} y=0 - y-position of specified rectangle\n     * @param  {number} width=0 - width of specified rectangle\n     * @param  {number} height=0 - height of specified rectangle\n     * @return {Rectangle} instance of Rectangle\n     */\n    constructor(x=0, y=0, width=0, height=0) {\n        super(x, y);\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n\n    /**\n     * Checks whether Rectangle intersects with specified Rectangle\n     * @param  {Rectangle} rect - the specified rectangle to check against\n     * @return {Boolean} true if containment is entirely\n     */\n    intersects(rect) {\n        return !(rect.left > this.right || rect.right < this.left || rect.top > this.bottom || rect.bottom < this.top);\n    }\n\n    /**\n     * Checks whether Rectangle entirely contains the Rectangle or Point\n     * @param  {Rectangle|Point} rectOrPoint - the specified point or rectangle to check against\n     * @return {Boolean} true if containment is entirely\n     */\n    contains(rectOrPoint) {\n        return (rectOrPoint instanceof Rectangle) ? this.containsRect(rectOrPoint) : (rectOrPoint instanceof Point) ? this.containsPoint(rectOrPoint) : false;\n    }\n\n    /**\n     * Sets the center of this Rectangle to specified point\n     * @param  {Point} point - specified point to set center of rectangle to\n     * @return {Rectangle} instance of Rectangle\n     */\n    setCenter(point) {\n        const difference = point.substract(this.center);\n        this.translate(difference.x, difference.y);\n        return this;\n    }\n\n    /**\n     * Sets the x-center of this Rectangle to specified x\n     * @param  {number} x - specified x coordinate to set x center of rectangle to\n     * @return {Rectangle} instance of Rectangle\n     */\n    setCenterX(x) {\n        const difference = x - this.center.x;\n        this.translate(difference, 0);\n        return this;\n    }\n\n    /**\n     * Sets the y-center of this Rectangle to specified y\n     * @param  {number} y - specified y coordinate to set y center of rectangle to\n     * @return {Rectangle} instance of Rectangle\n     */\n    setCenterY(y) {\n        const difference = y - this.center.y;\n        this.translate(0, difference);\n        return this;\n    }\n\n\n    /**\n     * Checks whether Rectangle entirely contains the Point\n     * @param  {Point} point - the specified point to check against\n     * @return {Boolean} true if containment is entirely\n     */\n    containsPoint(point) {\n        return (point instanceof Point) ? point.x >= this.left && point.y >= this.top && point.x <= this.right && point.y <= this.bottom : false;\n    }\n\n    /**\n     * Checks whether Rectangle entirely contains the Rectangle\n     * @param  {Rectangle} rect - the specified rectangle to check against\n     * @return {Boolean} true if containment is entirely\n     */\n    containsRect(rect) {\n        return (rect instanceof Rectangle) ? rect.left >= this.left && rect.top >= this.top && rect.right <= this.right && rect.bottom <= this.bottom : false;\n    }\n\n    /**\n     * distorts rectangle by factor\n     * @param  {number} factor - the specified factor of distortion\n     * @return {Rectangle} a new instance of Rectangle\n     */\n    getDistortedRect(factor) {\n        return new Rectangle(this.x, this.y, this.width, this.height).scaleX(factor);\n    }\n\n    /**\n     * redistorts rectangle by factor\n     * @param  {number} factor - the specified factor of distortion\n     * @return {Rectangle} a new instance of Rectangle\n     */\n    getNormalRect(factor) {\n        return new Rectangle(this.x, this.y, this.width, this.height).scaleX(1/factor);\n    }\n\n    /**\n     * scale x and width of rectangle\n     * @param  {number} x - factor to be applied to scale\n     * @return {Rectangle} scaled Rectangle\n     */\n    scaleX(x) {\n        this.x *= x;\n        this.width *= x;\n        return this;\n    }\n\n    /**\n     * scale y and height of rectangle\n     * @param  {number} y - factor to be applied to scale\n     * @return {Rectangle} new scaled Rectangle\n     */\n    scaleY(y) {\n        this.y *= y;\n        this.height *= y;\n        return this;\n    }\n\n    /**\n     * scale x and y for width and height of rectangle\n     * @param  {number} x - factor to be applied to scale\n     * @param  {number} y = x - factor to be applied to scale\n     * @return {Rectangle} new scaled Rectangle\n     */\n    scale(x, y = x) {\n        this.x *= x;\n        this.y *= y;\n        this.width *= x;\n        this.height *= y;\n        return this;\n    }\n\n    /**\n     * moves a rectangle by specified coords\n     * @param  {number} x - specified x to be added to x position\n     * @param  {number} y - specified y to be added to y position\n     * @return {Rectangle} Returns the altered rectangle\n     */\n    translate(x, y) {\n        super.translate(x, y);\n        return this;\n    }\n\n    /**\n     * transforms a rectangle by specified coords\n     * @param  {number} x - specified x to be added to x position\n     * @param  {number} y - specified y to be added to y position\n     * @param  {number} width - specified width to be added to this width\n     * @param  {number} height - specified height to be added to this height\n     * @return {Rectangle} Returns the altered rectangle\n     */\n    transform(x, y, width, height) {\n        this.translate(x, y);\n        this.width += width;\n        this.height += height;\n        return this;\n    }\n\n    /**\n     * changes the position a rectangle by specified coords\n     * @param  {number} x - the new x position\n     * @param  {number} y - he new y position\n     * @return {Rectangle} Returns the altered rectangle\n     */\n    position(x, y) {\n        super.position(x, y);\n        return this;\n    }\n\n    /**\n     * changes the size of a rectangle by specified params\n     * @param  {number} x - the new x position\n     * @param  {number} y - the new y position\n     * @param  {number} width - the new width\n     * @param  {number} height - the new width\n     * @return {Rectangle} Returns the altered rectangle\n     */\n    size(x, y, width, height) {\n        this.position(x, y);\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n\n    /**\n     * changes the size of a rectangle by specified params\n     * @param  {number} width - the new width\n     * @param  {number} height - the new width\n     * @return {Rectangle} Returns the altered rectangle\n     */\n    setSize(width, height) {\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n\n    /**\n     * check if rectangles are equal\n     * @param  {Rectangle} rectangle - the specified rectangle to check against this\n     * @return {Boolean} is true, if x, y, width and height are the same\n     */\n    equals(rectangle) {\n        return (rectangle instanceof Rectangle) ? this.x === rectangle.x && this.y === rectangle.y && this.width === rectangle.width && this.height === rectangle.height : false;\n    }\n\n}\n\n/**\n * Creates a Rectangle from specified Rectangle\n * @param  {Rectangle} rect - specified Rectangle\n * @return {Rectangle} the point specified\n */\nRectangle.createFromRectangle = (rect) => new Rectangle(rect.x, rect.y, rect.width, rect.height);\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Rectangle.js\n **/","import {StateHandler} from './StateHandler.js';\nimport {Rectangle} from './Rectangle.js';\nimport {Helper} from './Helper.js';\n\n/**\n * States of a tile\n * @type {Array}\n */\nconst STATES = [\n    {value: 0, description: 'Starting'},\n    {value: 1, description: 'Initialized'},\n    {value: 2, description: 'Loaded'},\n    {value: 3, description: 'Drawn'}\n];\n\nexport class Tile extends Rectangle {\n\n    /**\n     * Constructor\n     * @param  {string} path=null - path to image\n     * @param  {number} x=0 - position x of tile\n     * @param  {number} y=0 - position y of tile\n     * @param  {number} w=0 - tile width\n     * @param  {number} h=0 - tile height\n     * @param  {View} _instance = null - instance of parent View\n     * @return {Tile} instance of Tile\n     */\n    constructor({path, x = 0, y = 0, w = 0, h = 0} = {}, _instance = null) {\n        super(x, y, w, h);\n        this.state = new StateHandler(STATES);\n        if (!path || typeof path !== \"string\" || path.length === 0) {\n            throw new TypeError(`Path ${path} needs to be of type string and should not be empty`);\n        } else if(!_instance) {\n            throw new Error(`Tile needs an instance`);\n        }\n        this.instance = _instance;\n        this.markers = [];\n        this.context = this.instance.context;\n        this.path = path;\n        return this;\n    }\n\n    /**\n     * initializes tile and starts loading image\n     * @return {Tile} instance of Tile for chaining\n     */\n    initialize() {\n        this.state.next();\n        Helper.loadImage(this.path, function(img) {\n            this.img = img;\n            this.state.next();\n            this.draw();\n        }.bind(this));\n\n        return this;\n    }\n\n    addMarker(marker) {\n        this.markers.push(marker);\n    }\n\n    /**\n     * draws image data of tile on context\n     * @return {Tile} instance of Tile for chaining\n     */\n    draw() {\n        const distortedTile = this.clone.scale(this.instance.zoomFactor)\n                                        .translate(this.instance.currentView.x, this.instance.currentView.y)\n                                        .scaleX(this.instance.distortionFactor)\n                                        .translate(this.instance.offsetToCenter, 0);\n        if (this.state.current.value >= 2) {\n            if (!this.context) {\n                console.error(\"context not specified\", this);\n                return false;\n            }\n            this.state.next();\n            this.context.drawImage(this.img, distortedTile.x, distortedTile.y, distortedTile.width, distortedTile.height);\n        } else if (this.state.current.value === 0) {\n            this.initialize();\n        }\n        return this;\n    }\n\n    /**\n     * check if tiles are equal\n     * @param  {Tile} tile - the specified tile to check against this\n     * @return {Boolean} is true, if x, y, width and height and path are the same\n     */\n    equals(tile) {\n        return (tile instanceof Tile) ? super.equals(tile) && this.path === tile.path : false;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Tile.js\n **/","export class StateHandler {\n\n    /**\n     * get current state\n     * @return {Object} current state from STATES-array\n     */\n    get current() {\n        return this.states[this.i];\n    }\n\n    /**\n     * get number of states\n     * @return {number} number of states\n     */\n    get length() {\n        return this.states.length;\n    }\n\n    /**\n     * Constructor\n     * @param  {Array} states_array=[{value: 0, description: 'Default'}] - [description]\n     * @return {StateHandler} instance of StateHandler\n     */\n    constructor(states_array=[{value: 0, description: 'Default'}]) {\n        this.states = states_array;\n        this.i = 0;\n        this.lastState = this.current;\n        return this;\n    }\n\n    /**\n     * get the next element\n     * @return {StateHandler} instance of StateHandler\n     */\n    next() {\n        this.lastState = this.current;\n        if (this.hasNext()) {\n            this.i++;\n        }\n        return this;\n    }\n\n    /**\n     * get the previous element\n     * @return {StateHandler} instance of StateHandler\n     */\n    previous() {\n        this.lastState = this.current;\n        if (this.hasPrevious()) {\n            this.i--;\n        }\n        return this;\n    }\n\n    /**\n     * change the state to specified state\n     * @param {number} state - index of state in array\n     * @return {StateHandler} instance of StateHandler\n     */\n    changeTo(state) {\n        if (state >= 0 && state < this.length) {\n            this.i = state;\n        }\n        return this;\n    }\n\n    /**\n     * change the state to specified value of specified property\n     * @param {number} state - index of state in array\n     * @return {StateHandler} instance of StateHandler\n     */\n    changeToValue(prop, value) {\n        for (var i = 0; i < this.length; i++) {\n            if (this.states[i] && value === this.states[i][prop]) {\n                this.i = i;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * checks if there is a next element\n     * @return {Boolean} wheter there is a next state or not\n     */\n    hasNext() {\n        return this.i < this.length-1;\n    }\n\n    /**\n     * checks if there is a previous element\n     * @return {Boolean} wheter there is a previous state or not\n     */\n    hasPrevious() {\n        return this.i > 0;\n    }\n\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/StateHandler.js\n **/","import $ from 'jQuery';\nimport {Point} from './Point.js';\n\nexport var Helper = {\n\n    /**\n     * request json-data from given file and calls callback on success\n     * @param  {string} filename - path to file\n     * @param  {Function} callback - function called when data is loaded successfully\n     * @return {Helper} Helper object for chaining\n     */\n    requestJSON: function(filename, callback) {\n        $.ajax({\n            type: \"GET\",\n            url: filename,\n            dataType: \"json\",\n            success: function(data) {\n                return callback(data);\n            },\n            error: function(response) {\n                if (response.status === 200) {\n                    throw new Error(\"The JSON submitted seems not valid\");\n                }\n                console.error(\"Error requesting file: \", response);\n            }\n        });\n        return this;\n    },\n    /**\n     * loads an image and calls callback on success\n     * @param {Function} cb - callback-function on success\n     * @return {Helper} Helper object for chaining\n     */\n    loadImage: function(path, cb) {\n        const img = new Image();\n        img.onload = function() {\n            if (cb && typeof cb === \"function\") {\n                cb(img);\n            }\n        };\n        img.src = path;\n        return this;\n    },\n    /**\n     * for each helper\n     * @param  {Object[]} a - array to iterate over each value\n     * @param  {Function} fn - callback for each object\n     * @return {Helper} Helper object for chaining\n     */\n    forEach: function(a, fn) {\n        for (const i in a) {\n            if (a[i] && typeof fn === \"function\") {\n                fn(a[i], i);\n            }\n        }\n        return this;\n    },\n    /**\n     * formula for quadratic ease out\n     * @param  {number} t - current time\n     * @param  {Point} b - start value\n     * @param  {Point} c - total difference to start\n     * @param  {number} d - duration\n     * @return {number} quadratic value at specific time\n     */\n    easeOutQuadratic: function (t, b, c, d) {\n\t    t /= d;\n        return c.clone.multiply(-1 * t * (t-2)).add(b);\n    },\n\n    /**\n     * convert degree to radian\n     * @param {number} degrees - specified degrees\n     * @return {number} converted radian\n     */\n    toRadians: degrees => degrees * Math.PI / 180,\n    /**\n     * checks if mouse is possible\n     * @return {Boolean} if true, mouse is possible\n     */\n    isMouse: () => ('onmousedown' in window),\n\n    /**\n     * checks if touch is possible\n     * @return {Boolean} if true, touch is possible\n     */\n    isTouch: () => (('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)),\n\n    /**\n     * checks if IE is used\n     * @return {Boolean} if true, IE is used\n     */\n    isIE: () => ((navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)),\n\n    /**\n     * gets cross-browser scroll-event\n     * @return {string} name of scroll event\n     */\n    scrollEvent: () => \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : document.onmousewheel !== undefined ? \"mousewheel\" : \"DOMMouseScroll\"\n\n\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Helper.js\n **/","import $ from 'jQuery';\nimport {Point} from './Point.js';\nimport {StateHandler} from './StateHandler.js';\nimport {DataEnrichment} from './DataEnrichment.js';\n\n/**\n * States of a marker\n * @type {Array}\n */\nconst STATES = [\n    {value: 0, description: 'Loading'},\n    {value: 0, description: 'Initialized'},\n    {value: 1, description: 'Ready'}\n];\n\nexport class Marker {\n\n    /**\n     * Constructor\n     * @param  {Object} data = DataEnrichment.DATA_MARKER - enriched data\n     * @param  {View} _instance = parent instance - instance of parent view\n     * @return {Marker} - instance of Marker for chaining\n     */\n    constructor(data = DataEnrichment.DATA_MARKER, _instance = null) {\n\n        this.stateHandler = new StateHandler(STATES);\n\n        if(!_instance) {\n            throw new Error(`Tile needs an instance`);\n        }\n        this.instance = _instance;\n\n        this.size = data.size;\n        this.hover = data.hover;\n        if (this.hover) {\n            this.size.divide(2, 1);\n        }\n        this.img = data.icon;\n        this.offset = data.offset;\n        this.offset.add(new Point(-(this.size.x/2), -this.size.y));\n        this.latlng = data.latlng;\n\n        this.position = this.instance.convertLatLngToPoint(this.latlng);\n\n        this.icon = this.addMarkerToDOM(this.instance.$markerContainer);\n\n        this.positionMarker();\n\n        return this;\n    }\n\n    /**\n     * adds a marker to the DOM\n     * @param {Object} $container - container to append to (jQuery selector)\n     * @returns {Object} jQuery-selector of append markup\n     */\n    addMarkerToDOM($container) {\n        const icon = $(\"<div class='marker' />\").css({\n            \"width\": `${this.size.x}px`,\n            \"height\": `${this.size.y}px`,\n            \"margin-left\": `${this.offset.x}px`,\n            \"margin-top\": `${this.offset.y}px`,\n            \"background-image\": `url(${this.img})`,\n            \"background-size\": `${(this.hover) ? this.size.x*2 : this.size.x}px ${this.size.y}px`\n        });\n        if ($container) {\n            icon.hide();\n            $container.append(icon);\n            this.stateHandler.next();\n        }\n        return icon;\n    }\n\n    /**\n     * set initial position of this marker\n     * @return {Marker} - instance of Marker for chaining\n     */\n    positionMarker() {\n        this.position = this.instance.convertLatLngToPoint(this.latlng);\n        //const p = new Point((this.position.x + this.instance.currentView.x) * this.instance.distortionFactor + this.instance.offsetToCenter, this.position.y + this.instance.currentView.y);\n        if (this.icon) {\n            this.icon.css({\n                \"left\": `${this.position.x / this.instance.currentView.width * 100}%`,\n                \"top\": `${this.position.y / this.instance.currentView.height * 100}%`\n                //transform: `translate3d(${p.x}px, ${p.y}px, 0)`\n            });\n            this.icon.show();\n        }\n        return this;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Marker.js\n **/","import $ from 'jQuery';\nimport {Point} from './Point.js';\nimport {LatLng} from './LatLng.js';\nimport {Bounds} from './Bounds.js';\nimport {Helper} from './Helper.js';\n\nexport var DataEnrichment = {\n    /**\n     * enriches marker data with all needed data\n     * @param  {object} data - specified data for marker\n     * @param  {Function} cb - callback function, when enrichment is done\n     * @return {DataEnrichment} DataEnrichment object for chaining\n     */\n    marker: function(data, cb) {\n\n        const enrichedData = [];\n\n        Helper.forEach(data, function(entry) {\n\n            entry = $.extend(true, DataEnrichment.DATA_MARKER, entry);\n\n            const offset = new Point(entry.offset.x, entry.offset.y);\n            const latlng = new LatLng(entry.position.lat, entry.position.lng);\n            const size = new Point(entry.size.width, entry.size.height);\n\n            enrichedData.push({\n                offset: offset,\n                latlng: latlng,\n                size: size,\n                hover: entry.hover,\n                icon: entry.icon\n            });\n\n        });\n\n        if (typeof cb === \"function\") {\n            cb(enrichedData);\n        }\n\n        return this;\n    },\n    mapSettings: function(data) {\n\n        const enrichedData = $.extend(true, DataEnrichment.MAP_SETTINGS, data);\n\n        const bounds = new Bounds(new LatLng(enrichedData.bounds.northWest[0], enrichedData.bounds.northWest[1]), new LatLng(enrichedData.bounds.southEast[0], enrichedData.bounds.southEast[1]));\n        const center = new LatLng(enrichedData.center.lat, enrichedData.center.lng);\n\n        enrichedData.bounds = bounds;\n        enrichedData.center = center;\n\n        return enrichedData;\n    }\n};\n\n/**\n * Default initial values for a Marker\n * @type {Object}\n */\nDataEnrichment.DATA_MARKER = {\n    icon: null,\n    hover: false,\n    position: {\n        lat: 0,\n        lng: 0\n    },\n    offset: {\n        x: 0,\n        y: 0\n    },\n    size: {\n        width: 32,\n        height: 32\n    }\n};\n\nDataEnrichment.MAP_SETTINGS = {\n    level: 0,\n    center: {\"lat\": 0, \"lng\": 0},\n    bounds: {\n        \"top\": 90,\n        \"left\": -180,\n        \"width\": 360,\n        \"height\": 180\n    },\n    controls: {\n        zoom: false,\n        home: false,\n        position: \"bottom-right\",\n        theme: \"dark\"\n    }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/DataEnrichment.js\n **/","/*global PointerEvent,MSPointerEvent*/\n\nimport $ from 'jQuery';\nimport {Point} from './Point.js';\nimport {Helper} from './Helper.js';\n\nexport class Interact {\n\n\n    /**\n     * get time difference to last\n     * @return {number} difference\n     */\n    get timeToLastMove() {\n        return this.data.time.end - this.data.time.last;\n    }\n\n    /**\n     * get time difference to start\n     * @return {number} difference\n     */\n    get time() {\n        return this.data.time.end - this.data.time.start;\n    }\n\n    /**\n     * clones the data object\n     * @return {Object} data object\n     */\n    get dataClone() {\n        return $(this.data)[0];\n    }\n\n    /**\n     * Constructor\n     * @param {Object} settings = {} - all the settings\n     * @param {string|Object} settings.container = \".interact-container\" - Container, either string, jQuery-object or dom-object\n     * @param {Object} settings.timeTreshold = {} - settings for the timing tresholds\n     * @param {number} settings.timeTreshold.tap = 200 - timing treshold for tap\n     * @param {number} settings.timeTreshold.hold = 500 - timing treshold for hold\n     * @param {number} settings.timeTreshold.swipe = 300 - timing treshold for swipe\n     * @param {number} settings.timeTreshold.flick = 30 - timing treshold for flick\n     * @param {Object} settings.distanceTreshold = {} - settings for the distance tresholds\n     * @param {number} settings.distanceTreshold.swipe = 200 - distance treshold for swipe\n     * @param {Boolean|string} settings.overwriteViewportSettings = false - on true prevents pinching, can be a custom string too\n     * @param {Boolean} settings.stopPropagation = true - on true stops the propagation of events\n     * @param {Boolean} settings.preventDefault = true - on true prevents the default actions of events\n     * @param {Boolean} settings.autoFireHold = false - if set to false hold-event is not fired\n     * @param {number} settings.pinchBalanceTime = 50 - prevents from firing too much pinching events\n     * @param {Object} settings.callbacks = {} - settings for the callback-functions\n     * @param {function} settings.callbacks.tap = null - callback-function for tap\n     * @param {function} settings.callbacks.tapHold = null - callback-function for tapHold\n     * @param {function} settings.callbacks.doubletap = null - callback-function for doubletap\n     * @param {function} settings.callbacks.hold = null - callback-function for hold\n     * @param {function} settings.callbacks.pan = null - callback-function for pan\n     * @param {function} settings.callbacks.swipe = null - callback-function for swipe\n     * @param {function} settings.callbacks.flick = null - callback-function for flick\n     * @param {function} settings.callbacks.zoom = null - callback-function for zoom\n     * @param {function} settings.callbacks.wheel = null - callback-function for wheel\n     * @param {function} settings.callbacks.pinch = null - callback-function for pinch\n     * @param {Object} settings.events = {} - settings all eventnames\n     * @param {Object} settings.events.start = {} - settings all start eventnames\n     * @param {Object} settings.events.start.touch = (\"MSPointerDown pointerdown\" || \"touchstart\") - settings start touch eventnames\n     * @param {Object} settings.events.start.mouse = (\"MSPointerDown pointerdown\" || \"mousedown\") - settings start mouse eventnames\n     * @param {Object} settings.events.move = {} - settings all move eventnames\n     * @param {Object} settings.events.move.touch = (\"MSPointerMove pointermove\" || \"touchmove\") - settings move touch eventnames\n     * @param {Object} settings.events.move.mouse = (\"MSPointerMove pointermove\" || \"mousemove\") - settings move mouse eventnames\n     * @param {Object} settings.events.end = {} - settings all end eventnames\n     * @param {Object} settings.events.end.touch = (\"MSPointerUp pointerup\" || \"touchend\") - settings end touch eventnames\n     * @param {Object} settings.events.end.mouse = (\"MSPointerUp pointerup\" || \"mouseup\") - settings end mouse eventnames\n     * @param {Object} settings.events.leave = {} - settings all leave eventnames\n     * @param {Object} settings.events.leave.touch = (\"MSPointerLeave pointerleave\" || \"touchleave\") - settings leave touch eventnames\n     * @param {Object} settings.events.leave.mouse = (\"MSPointerLeave pointerleave\" || \"mouseleave\") - settings leave mouse eventnames\n     * @param {string} settings.events.scroll = (\"wheel\" || \"mousewhell\" || \"DOMMouseScroll\") - settings all scroll eventnames\n     * @return {Interact} new instance\n     */\n    constructor(settings = {}) {\n        this.settings = this.getDefaultSettings();\n\n        $.extend(true, this.settings, settings || {});\n\n        this.data = this.getDefaultData();\n\n        if (this.settings.overwriteViewportSettings) {\n            this.handleViewport(this.settings.overwriteViewportSettings);\n        }\n\n        this.init(this.settings.container).bindEvents();\n\n    }\n\n    /**\n     * get the default settings\n     * @return {Object} settings\n     */\n    getDefaultSettings() {\n        return {\n            container: \".interact-container\",\n            timeTreshold: {\n                tap: 200,\n                hold: 500,\n                swipe: 300,\n                flick: 20\n            },\n            distanceTreshold: {\n                swipe: 200\n            },\n            speedThreshold: 0.01,\n            overwriteViewportSettings: false,\n            stopPropagation: true,\n            preventDefault: true,\n            autoFireHold: false,\n            pinchBalanceTime: 20,\n            callbacks: this.getDefaultCallbacks(),\n            events: this.getDefaultEventNames()\n        };\n    }\n\n    /**\n     * get default callbacks\n     * @return {Object} callbacks\n     */\n    getDefaultCallbacks() {\n        return {\n            tap: null,\n            tapHold: null,\n            doubletap: null,\n            hold: null,\n            pan: null,\n            swipe: null,\n            flick: null,\n            zoom: null,\n            wheel: null,\n            pinch: null\n        };\n    }\n\n    /**\n     * get default eventnames\n     * @return {Object} eventnames\n     */\n    getDefaultEventNames() {\n        return {\n            start: {\n                touch: (Helper.isIE()) ? \"MSPointerDown pointerdown\" : \"touchstart\",\n                mouse: (Helper.isIE()) ? \"MSPointerDown pointerdown\" : \"mousedown\"\n            },\n            move: {\n                touch: (Helper.isIE()) ? \"MSPointerMove pointermove\" : \"touchmove\",\n                mouse: (Helper.isIE()) ? \"MSPointerMove pointermove\" : \"mousemove\"\n            },\n            end: {\n                touch: (Helper.isIE()) ? \"MSPointerUp pointerup\" : \"touchend\",\n                mouse: (Helper.isIE()) ? \"MSPointerUp pointerup\" : \"mouseup\"\n            },\n            leave: {\n                touch: (Helper.isIE()) ? \"MSPointerLeave pointerleave\" : \"touchleave\",\n                mouse: (Helper.isIE()) ? \"MSPointerLeave pointerleave\" : \"mouseleave\"\n            },\n            scroll: Helper.scrollEvent()\n        };\n    }\n\n    /**\n     * get default data\n     * @return {Object} data\n     */\n    getDefaultData() {\n        return {\n            down: false,\n            moved: false,\n            pinched: false,\n            pointerArray: {},\n            multitouch: false,\n            distance: null,\n            directions: [],\n            zoom: 0,\n            difference: null,\n            target: null,\n            last: {\n                position: null,\n                distance: null,\n                action: null\n            },\n            position: {\n                start: null,\n                move: null,\n                end: null\n            },\n            time: {\n                start: null,\n                last: null,\n                end: null\n            },\n            timeout: {\n                hold: null,\n                default: null\n            }\n        };\n    }\n\n    /**\n     * handles the overwrite of viewport meta\n     * @param  {Boolean|string} viewport - specified viewport option\n     * @return {Interact} Returns this instance\n     */\n    handleViewport(viewport) {\n        if (typeof viewport !== \"string\") {\n            viewport = \"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\";\n        }\n        const metaViewInHead = $(\"meta[name=viewport]\").length,\n              $viewportMeta = (metaViewInHead !== 0) ? $(\"meta[name=viewport]\") : $(\"head\").append($(\"<meta name='viewport' />\"));\n        $viewportMeta.attr(\"content\", viewport);\n        return this;\n    }\n\n    /**\n     * initializes class settings and bindings\n     * @param  {Object|string} container - Container, either string, jQuery-object or dom-object\n     * @return {Interact} Returns this instance\n     */\n    init(container) {\n        this.$container = (typeof container === \"string\") ? $(container) : ((typeof container === \"object\" && container instanceof jQuery) ? container : $(container));\n        if (!(this.$container instanceof jQuery)) {\n            throw new Error(\"Container \" + container + \" not found\");\n        }\n        this.$container.css({\n            \"-ms-touch-action\": \"none\",\n            \"touch-action\": \"none\",\n            \"-ms-content-zooming\": \"none\"\n        });\n        this.$container.find(\"> *\").css({\n            \"-ms-touch-action\": \"none\",\n            \"touch-action\": \"none\",\n            \"-ms-content-zooming\": \"none\"\n        });\n        this.container = this.$container[0];\n        return this;\n    }\n\n    /**\n     * binds all needed events\n     * @return {Interact} Returns this instance\n     */\n    bindEvents() {\n        if (Helper.isIE()) {\n            this.bindIEEvents();\n        } else {\n            if (Helper.isTouch()) {\n                this.bindTouchEvents();\n            }\n            if (Helper.isMouse()) {\n                this.bindMouseEvents();\n            }\n        }\n        return this;\n    }\n\n    /**\n     * binds all needed events for IE\n     * @return {Interact} Returns this instance\n     */\n    bindIEEvents() {\n        this.$container.on(this.settings.events.scroll, this.scrollHandler.bind(this));\n        this.bindTouchEvents();\n        this.container.addEventListener(\"contextmenu\", function(e) {\n            e.preventDefault();\n        }, false);\n        return this;\n    }\n\n    /**\n     * binds all needed events for touch devices\n     * @return {Interact} Returns this instance\n     */\n    bindTouchEvents() {\n        this.$container\n            .on(this.settings.events.start.touch, this.startHandler.bind(this))\n            .on(this.settings.events.move.touch, this.moveHandler.bind(this))\n            .on(this.settings.events.end.touch, this.endHandler.bind(this))\n            .on(this.settings.events.leave.touch, this.endHandler.bind(this));\n        return this;\n    }\n\n    /**\n     * binds all needed events for mouse devices\n     * @return {Interact} Returns this instance\n     */\n    bindMouseEvents() {\n        this.$container.on(this.settings.events.scroll, this.scrollHandler.bind(this))\n            .on(this.settings.events.start.mouse, this.startHandler.bind(this))\n            .on(this.settings.events.move.mouse, this.moveHandler.bind(this))\n            .on(this.settings.events.end.mouse, this.endHandler.bind(this))\n            .on(this.settings.events.leave.mouse, this.endHandler.bind(this));\n        return this;\n    }\n\n    /**\n     * pre handle all events\n     * @param  {Object} event - original event of Vanilla JS\n     * @return {Object} normalized jQuery-fixed event\n     */\n    preHandle(event) {\n        if (this.settings.stopPropagation) {\n            event.stopPropagation();\n        }\n        if (this.settings.preventDefault) {\n            event.preventDefault();\n        }\n\n        this.data.target = event.target;\n\n        return this.getEvent(event);\n    }\n\n    /**\n     * handles cross-browser and -device scroll\n     * @param  {Object} event - jQuery-Event-Object\n     * @return {Boolean} always returns false\n     */\n    scrollHandler(event) {\n        event = event || window.event;\n\n        const e = this.preHandle(event) || event.originalEvent;\n\n        this.data.position.start = this.getRelativePosition(e);\n        this.data.directions = this.getScrollDirection(e);\n\n        this.data.zoom = (this.data.directions.indexOf(\"up\") > -1) ? 1 : (this.data.directions.indexOf(\"down\") > -1) ? -1 : 0;\n\n        if (this.settings.callbacks.wheel) {\n            this.eventCallback(this.settings.callbacks.wheel, this.dataClone);\n        }\n        if (this.settings.callbacks.zoom && (this.data.directions.indexOf(\"up\") > -1 || this.data.directions.indexOf(\"down\") > -1)) {\n            this.eventCallback(this.settings.callbacks.zoom, this.dataClone);\n        }\n\n        return false;\n    }\n\n    /**\n     * check if event is a PointerEvent (IE)\n     * @param  {Object} event - original event of Vanilla JS\n     * @return {Boolean} Whether event is PointerEvent\n     */\n    isPointerEvent(e) {\n        return Helper.isIE() && (e instanceof MSPointerEvent || e instanceof PointerEvent);\n    }\n\n    /**\n     * calculation to be made at start-handler\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} calculated data\n     */\n    calculateStart(e) {\n        const data = {\n            multitouch: false,\n            distance: 0,\n            down: true,\n            position: {\n                start: new Point()\n            }\n        };\n        // mouse is used\n        if (e instanceof MouseEvent && !this.isPointerEvent(e)) {\n            return $.extend(true, data, this.handleSingletouchStart(e));\n        }\n        // if is pointerEvent\n        if (this.isPointerEvent(e)) {\n            return this.handlePointerEventStart(data, e);\n        } // touch is used\n        else { // singletouch startet\n            return this.handleTouchEventStart(data, e);\n        }\n    }\n\n    /**\n     * handle PointerEvent calculations\n     * @param  {Object} data - current data\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} manipulated enriched data\n     */\n    handlePointerEventStart(data, e) {\n        this.data.pointerArray[e.pointerId] = e;\n        if (Object.keys(this.data.pointerArray).length <= 1) {\n            return $.extend(true, data, this.handleSingletouchStart(e));\n        } else {\n            return $.extend(true, data, this.handleMultitouchStart(this.getPointerArray()));\n        }\n    }\n\n    /**\n     * handle TouchEvent calculations for start\n     * @param  {Object} data - current data\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} manipulated enriched data\n     */\n    handleTouchEventStart(data, e) {\n        if (e.length === 1) {\n            return $.extend(true, data, this.handleSingletouchStart(e[0]));\n        } // multitouch started\n        else if (e.length === 2) {\n            return $.extend(true, data, this.handleMultitouchStart(e));\n        }\n        return data;\n    }\n\n    /**\n     * get array of pointers (IE)\n     * @return {Object} array of pointerIDs\n     */\n    getPointerArray() {\n        const pointerPos = [];\n        for (const pointer in this.data.pointerArray) {\n            if (this.data.pointerArray[pointer]) {\n                pointerPos.push(this.data.pointerArray[pointer]);\n            }\n        }\n        return pointerPos;\n    }\n\n    /**\n     * handles multitouch for start\n     * @param  {Object} positionsArray - array of positions\n     * @return {Object} manipulated enriched data\n     */\n    handleMultitouchStart(positionsArray) {\n        const pos1 = this.getRelativePosition(positionsArray[0]),\n              pos2 = this.getRelativePosition(positionsArray[1]);\n        return {\n            multitouch: true,\n            distance: pos1.distance(pos2),\n            position: {\n                start: pos1.add(pos2).divide(2, 2)\n            }\n        };\n    }\n\n    /**\n     * handles singletouch for start\n     * @param  {Point} position - position of touch\n     * @return {Object} manipulated enriched data\n     */\n    handleSingletouchStart(position) {\n        return {\n            position: {\n                start: this.getRelativePosition(position)\n            }\n        };\n    }\n\n    /**\n     * handle action at start event handler\n     * @param  {String} action - last action made\n     * @return {Interact} instance of Interact for chaining\n     */\n    takeActionStart(action) {\n        switch (action) {\n            case null:\n                this.data.last.action = \"tap\";\n                if (this.settings.autoFireHold) {\n                    this.setTimeoutForEvent(this.settings.callbacks.hold, this.settings.autoFireHold, this.dataClone, true);\n                }\n                break;\n            case \"tap\":\n                this.data.last.action = \"doubletap\";\n                if (this.settings.autoFireHold) {\n                    this.setTimeoutForEvent(this.settings.callbacks.tapHold, this.settings.autoFireHold, this.dataClone, true);\n                }\n                break;\n            default:\n                break;\n        }\n        return this;\n    }\n\n    /**\n     * handles cross-browser and -device start-event\n     * @param  {Object} event - jQuery-Event-Object\n     * @return {Boolean} always returns false\n     */\n    startHandler(event) {\n        if (event.button && event.button !== 0) {\n            return false;\n        }\n        const e = this.preHandle(event);\n        this.data.time.start = event.timeStamp;\n        this.clearTimeouts(this.data.timeout.default);\n        this.data = $.extend(true, this.data, this.calculateStart(e));\n        this.takeActionStart(this.data.last.action);\n        return false;\n    }\n\n    /**\n     * clear timeout helper\n     * @param  {Object} timeout - timeout object to be cleared\n     * @return {Interact} instance of Interact for chaining\n     */\n    clearTimeouts(timeout) {\n        if (timeout) {\n            timeout = clearTimeout(timeout);\n        }\n        return this;\n    }\n\n    /**\n     * calculation to be made at move-handler\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} calculated data\n     */\n    calculateMove(e) {\n        const data = {\n            moved: true,\n            last: {\n                action: \"moved\"\n            },\n            position: {\n                move: new Point()\n            }\n        };\n\n        if (e instanceof MouseEvent && !this.isPointerEvent(e)) {\n            return $.extend(true, data, this.handleSingletouchMove(e));\n        } // if is pointerEvent\n        if (this.isPointerEvent(e)) {\n            return this.handlePointerEventMove(data, e);\n        } // touch is used\n        else {\n            return this.handleTouchEventMove(data, e);\n        }\n    }\n\n    /**\n     * handle PointerEvent at moving (IE)\n     * @param  {Object} data - specified input data\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} manipulated enriched data\n     */\n    handlePointerEventMove(data, e) {\n        this.data.pointerArray[e.pointerId] = e;\n        if (Object.keys(this.data.pointerArray).length <= 1) {\n            return $.extend(true, data, this.handleSingletouchMove(e));\n        } else {\n            const pointerPos = this.getPointerArray();\n            return $.extend(true, data, this.handleMultitouchMove(pointerPos));\n        }\n    }\n\n    /**\n     * handle TouchEvent calculations for move\n     * @param  {Object} data - current data\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} manipulated enriched data\n     */\n    handleTouchEventMove(data, e) {\n        // singletouch startet\n        if (e.length === 1) {\n            return $.extend(true, data, this.handleSingletouchMove(e[0]));\n        } else if (e.length === 2) {\n            return $.extend(true, data, this.handleMultitouchMove(e));\n        }\n        return data;\n    }\n\n    /**\n     * handles multitouch for move\n     * @param  {Object} positionsArray - array of positions\n     * @return {Object} manipulated enriched data\n     */\n    handleMultitouchMove(positionsArray) {\n        const pointerPos1 = this.getRelativePosition(positionsArray[0]);\n        const pointerPos2 = this.getRelativePosition(positionsArray[1]);\n        const pos = pointerPos2.clone.add(pointerPos1).divide(2);\n        return {\n            position: {\n                move: pos\n            },\n            distance: pointerPos1.distance(pointerPos2),\n            multitouch: true\n        };\n    }\n\n    /**\n     * handles singletouch for move\n     * @param  {Point} position - position\n     * @return {Object} manipulated enriched data\n     */\n    handleSingletouchMove(position) {\n        const pos = this.getRelativePosition(position);\n        return {\n            position: {\n                move: pos\n            },\n            distance: this.data.last.position.distance(pos),\n            multitouch: false\n        };\n    }\n\n    /**\n     * handles cross-browser and -device move-event\n     * @param  {Object} event - jQuery-Event-Object\n     * @return {Boolean} always returns false\n     */\n    moveHandler(event) {\n        // if touchstart event was not fired\n        if (!this.data.down || this.data.pinched) {\n            return false;\n        }\n\n        const e = this.preHandle(event);\n        this.data.time.last = event.timeStamp;\n        this.data.last.position = (this.data.position.move) ? this.data.position.move : this.data.position.start;\n        this.data.time.last = (this.data.time.last) ? this.data.time.last : this.data.time.start;\n\n        // if positions have not changed\n        if (this.positionDidNotChange(e)) {\n            return false;\n        }\n\n        this.clearTimeouts(this.data.timeout.default);\n        this.clearTimeouts(this.data.timeout.hold);\n        this.data = $.extend(true, this.data, this.calculateMove(e));\n\n        if (this.data.multitouch) {\n            this.handlePinchAndZoom();\n        } else {\n            this.eventCallback(this.settings.callbacks.pan, this.dataClone);\n        }\n\n        return false;\n    }\n\n    /**\n     * handles pinch and zoom\n     * @return {Interact} instance of Interact for chaining\n     */\n    handlePinchAndZoom() {\n        if (!this.data.last.distance) {\n            this.data.last.distance = this.data.distance;\n        }\n        this.data.difference = this.data.distance - this.data.last.distance;\n        if (Math.abs(this.data.difference) >= 0.005) {\n            if (this.settings.callbacks.pinch) {\n                this.eventCallback(this.settings.callbacks.pinch, this.dataClone);\n            }\n            if (this.settings.callbacks.zoom) {\n                this.eventCallback(this.settings.callbacks.zoom, this.dataClone);\n            }\n            this.data.last.distance = this.data.distance;\n        }\n        return this;\n    }\n\n    /**\n     * check if position has been changed\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Boolean} Whether or not position has changed\n     */\n    positionDidNotChange(e) {\n        return Helper.isIE() && (this.getRelativePosition(e).equals(this.data.last.position) || this.getRelativePosition(e).equals(this.data.position.start)) || (!Helper.isIE() && Helper.isTouch() && this.getRelativePosition(e[0]).equals(this.data.last.position));\n    }\n\n    /**\n     * calculation to be made at end-handler\n     * @param  {Object} e - jQuery-Event-Object\n     * @return {Object} calculated data\n     */\n    calculateEnd(e) {\n        const data = {\n            position: {\n                end: new Point()\n            }\n        };\n\n        if (e instanceof MouseEvent && !this.isPointerEvent(e)) {\n            return $.extend(true, data, this.handleSingletouchEnd(e));\n        } // if is pointerEvent\n        if (this.isPointerEvent(e)) {\n            const end = this.handleSingletouchEnd(e);\n            delete this.data.pointerArray[e.pointerId];\n            return $.extend(true, data, end);\n        } // touch is used\n        else {\n            // singletouch ended\n            if (e.length <= 1) {\n                return $.extend(true, data,  this.handleSingletouchEnd(e[0]));\n            }\n        }\n    }\n\n    /**\n     * handles singletouch for end\n     * @param  {Object} position - position\n     * @return {Object} manipulated enriched data\n     */\n    handleSingletouchEnd(position) {\n        return {\n            position: {\n                end: this.getRelativePosition(position)\n            }\n        };\n    }\n\n    /**\n     * handle action at end event handler\n     * @param  {String} action - last action made\n     * @return {Interact} instance of Interact for chaining\n     */\n    takeActionEnd(action) {\n        switch (action) {\n            case \"tap\":\n                if (this.time < this.settings.timeTreshold.hold) {\n                    this.setTimeoutForEvent(this.settings.callbacks.tap, this.settings.timeTreshold.tap, this.dataClone);\n                } else {\n                    this.eventCallback(this.settings.callbacks.hold, this.dataClone);\n                }\n                break;\n            case \"doubletap\":\n                if (this.time < this.settings.timeTreshold.hold) {\n                    this.setTimeoutForEvent(this.settings.callbacks.doubletap, this.settings.timeTreshold.tap, this.dataClone);\n                } else {\n                    this.eventCallback(this.settings.callbacks.tapHold, this.dataClone);\n                }\n                break;\n            default:\n                this.data.last.action = null;\n        }\n    }\n\n    /**\n     * handles cross-browser and -device end-event\n     * @param  {Object} event - jQuery-Event-Object\n     * @return {Boolean} always returns false\n     */\n    endHandler(event) {\n\n        const e = this.preHandle(event);\n\n        this.data.time.end = event.timeStamp;\n\n        this.clearTimeouts(this.data.timeout.hold);\n\n        this.data = $.extend(true, this.data, this.calculateEnd(e));\n\n        // called only when not moved\n        if (!this.data.moved && this.data.down && !this.data.multitouch) {\n            this.takeActionEnd(this.data.last.action);\n        }\n        // if was moved\n        else if (this.data.moved && this.data.down && !this.data.multitouch) {\n            if (this.settings.callbacks.swipe || this.settings.callbacks.flick) {\n                this.handleSwipeAndFlick();\n            }\n            this.data.last.action = null;\n        }\n        this.pinchBalance();\n        this.handleMultitouchEnd(e);\n        this.data.last.position = null;\n        return false;\n    }\n\n    /**\n     * handles flick and swipe events\n     * @return {Interact} instance of Interact for chaining\n     */\n    handleSwipeAndFlick() {\n        const direction = this.data.position.end.clone.substract(this.data.last.position);\n\n        const vLDirection = direction.length,\n              directionNormalized = direction.divide(vLDirection, vLDirection);\n\n        if (this.settings.callbacks.swipe && this.time <= this.settings.timeTreshold.swipe) {\n            const originalStart = this.getAbsolutePosition(this.data.position.start);\n            const originalEnd = this.getAbsolutePosition(this.data.position.end);\n            if (originalEnd.distance(originalStart) >= this.settings.distanceTreshold.swipe) {\n                this.data.directions = this.getSwipeDirections(directionNormalized);\n                this.eventCallback(this.settings.callbacks.swipe, this.dataClone);\n            }\n        }\n\n        if (this.settings.callbacks.flick && (this.timeToLastMove <= this.settings.timeTreshold.flick)) {\n            const distance = this.data.last.position.distance(this.data.position.end);\n            this.data.distance = distance;\n            const direction = this.data.last.position.clone.substract(this.data.position.end);\n            this.data.directions = [direction.x, direction.y];\n            this.data.speed = this.calculateSpeed(distance, this.time);\n            if (this.data.speed >= this.settings.speedThreshold) {\n                this.eventCallback(this.settings.callbacks.flick, this.dataClone);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * handles multitouch for end\n     * @param  {e} e - jQuery-Event-Object\n     * @return {Interact} instance of Interact for chaining\n     */\n    handleMultitouchEnd(e) {\n        this.data.multitouch = false;\n        this.data.down = false;\n        this.data.moved = false;\n\n        // if is pointerEvent\n        if (this.isPointerEvent(e)) {\n            if (Object.keys(this.data.pointerArray).length > 1) {\n                this.data.multitouch = true;\n            } else if (Object.keys(this.data.pointerArray).length > 0) {\n                this.data.down = true;\n            }\n        } // touch is used\n        else {\n            if (e.length > 1) {\n                this.data.multitouch = true;\n            } else if (e.length > 0) {\n                this.data.down = true;\n            }\n            this.data.position.move = null;\n        }\n        return this;\n    }\n\n    /**\n     * balances pinching after release of finger\n     * @return {Interact} instance of Interact for chaining\n     */\n    pinchBalance() {\n        if (this.data.multitouch) {\n            this.data.pinched = true;\n            setTimeout((function() {\n                this.data.pinched = false;\n                this.data.last.distance = null;\n            }).bind(this), this.settings.pinchBalanceTime);\n        }\n        return this;\n    }\n\n    /**\n     * calculates the speed with specified distance and time\n     * @param  {number} distance - the specified distance\n     * @param  {number} time - the specified time elapsed\n     * @return {number} the calculated speed\n     */\n    calculateSpeed(distance, time) {\n        return (distance / (time || 0.00001)) * 100;\n    }\n\n    /**\n     * Returns an array of strings, representing the directions\n     * @param  {Point} direction - the specified direction in pixel\n     * @return {string[]} returns an array representing the directions as strings\n     */\n    getSwipeDirections(direction) {\n        return [(direction.x < 0) ? \"left\" : (direction.x > 0) ? \"right\" : \"none\", (direction.y < 0) ? \"up\" : (direction.y > 0) ? \"down\" : \"none\"];\n    }\n\n    /**\n     * Helper for setting a timeout for events\n     * @param {Function} callback - function to be called\n     * @param {number} timeout - time in milliseconds\n     * @param {Object[]} args - array of arguments\n     * @param {Boolean} holdTimeout - if true, a different variable will be used\n     * @return {Interact} Returns this instance\n     */\n    setTimeoutForEvent(callback, timeout, args, holdTimeout) {\n        if (holdTimeout) {\n            this.data.timeout.hold = setTimeout(this.eventCallback.bind(this, callback, args), timeout);\n        } else {\n            this.data.timeout.default = setTimeout(this.eventCallback.bind(this, callback, args), timeout);\n        }\n        return this;\n    }\n\n    /**\n     * Eventhandler for handling the callbacks\n     * @param  {Function} callback - function to be called\n     * @param  {object[]} args - arguments for the function\n     * @return {Interact} Returns this instance\n     */\n    eventCallback(callback, args) {\n        if (callback && typeof callback === \"function\") {\n            callback(args);\n        }\n        this.data.last.action = null;\n        return this;\n    }\n\n    /**\n     * get the relative position of clientX and clientY\n     * @param  {Object} e - event object\n     * @return {Point} calculated relative position\n     */\n    getRelativePosition(e) {\n        const clientBounds = this.container.getBoundingClientRect(),\n            pos = new Point(e.clientX, e.clientY),\n            bounds = new Point(clientBounds.left, clientBounds.top);\n        return pos.substract(bounds).divide(clientBounds.width, clientBounds.height);\n    }\n\n    /**\n     * get the absolute position of clientX and clientY\n     * @param  {Object} e - event object\n     * @return {Point} calculated absolute position\n     */\n    getAbsolutePosition(point) {\n        const clientBounds = this.container.getBoundingClientRect();\n        return point.mult(clientBounds.width, clientBounds.height);\n    }\n\n    /**\n     * get scroll direction from event\n     * @param  {Object} event - event object\n     * @return {string[]} an array with scroll directions\n     */\n    getScrollDirection(event) {\n        const axis = parseInt(event.axis, 10);\n        const direction = [];\n\n        // down\n        if (this.isDownDirection(axis, event)) {\n            direction.push(\"down\");\n        } // up\n        else if (this.isUpDirection(axis, event)) {\n            direction.push(\"up\");\n        }\n\n        // right\n        if (this.isRightDirection(axis, event)) {\n            direction.push(\"right\");\n        } // left\n        else if (this.isLeftDirection(axis, event)) {\n            direction.push(\"left\");\n        }\n\n        return direction;\n    }\n\n    /**\n     * checks if direction is down\n     * @param  {number} axis - what axis is used\n     * @param  {Object} event - Vanilla JS event\n     * @return {Boolean} Whether or not direction is down\n     */\n    isDownDirection(axis, event) {\n        return event.deltaY > 0 || (!event.deltaY && event.wheelDeltaY < 0) || ((axis === 2) && (event.detail > 0)) || (Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail))) < 0);\n    }\n\n    /**\n     * checks if direction is up\n     * @param  {number} axis - what axis is used\n     * @param  {Object} event - Vanilla JS event\n     * @return {Boolean} Whether or not direction is up\n     */\n    isUpDirection(axis, event) {\n        return event.deltaY < 0 || (!event.deltaY && event.wheelDeltaY > 0) || (axis === 2 && event.detail < 0) || (Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail))) > 0);\n    }\n\n    /**\n     * checks if direction is right\n     * @param  {number} axis - what axis is used\n     * @param  {Object} event - Vanilla JS event\n     * @return {Boolean} Whether or not direction is right\n     */\n    isRightDirection(axis, event) {\n        return event.deltaX > 0 || (!event.deltaX && event.wheelDeltaX > 0) || (axis === 1 && event.detail > 0);\n    }\n\n    /**\n     * checks if direction is left\n     * @param  {number} axis - what axis is used\n     * @param  {Object} event - Vanilla JS event\n     * @return {Boolean} Whether or not direction is left\n     */\n    isLeftDirection(axis, event) {\n        return event.deltaX < 0 || (!event.deltaX && event.wheelDeltaX < 0) || (axis === 1 && event.detail < 0);\n    }\n\n    /**\n     * Get event helper, applies jQuery-event-fix too\n     * @param  {Object} e - event object\n     * @return {Object} new fixed and optimized event\n     */\n    getEvent(e) {\n        jQuery.event.fix(e);\n        if (e.originalEvent.touches && e.originalEvent.touches.length === 0) {\n            return e.originalEvent.changedTouches || e.originalEvent;\n        }\n        return e.originalEvent.touches || e.originalEvent.changedTouches || e.originalEvent;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** plugin/src/js/Interact.js\n **/"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtCA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AACA;AACA;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAXA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAfA;AACA;AAXA;;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAMA;AACA;AAPA;AASA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;;;;;;;;;;AAQA;AACA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AALA;AAOA;AACA;AACA;AAFA;AAIA;AACA;AADA;AAGA;AACA;AACA;AADA;AAGA;AAJA;AAMA;AACA;AACA;AACA;AAHA;AArBA;AAJA;;;;;;;;;;AAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAGA;AACA;AACA;;;;AAGA;AACA;;;;AAGA;AACA;;;;AAGA;AACA;AACA;AACA;;AACA;AACA;AAHA;;AAKA;AACA;AANA;;AAQA;AACA;AATA;;AAWA;AACA;AAZA;;AAcA;AACA;AAfA;;AAiBA;AACA;AAlBA;;AAoBA;AACA;AArBA;;AAuBA;AACA;AAxBA;;AA0BA;AACA;AA3BA;AA6BA;AA7BA;AA+BA;;;;AAGA;AACA;AACA;;;;AAGA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;AAQA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AAFA;AAIA;;;;;;;;;;AAOA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;;;;AAhSA;;;;;;;ACRA;;;;;;;;;;;;;;;ACAA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AACA;;;;;;;;;AAMA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA1CA;AACA;AAyCA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AACA;;;;;;;AA1CA;;AA8DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;AAtJA;;;;;;;;;AA+JA;AACA;;;;;AAKA;;;;;;;;;;;;;;;AC3KA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AACA;;;;;;;;;AAMA;AACA;;;;;;;;;AAMA;AACA;;;;AAGA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AAFA;;;;;;;;;;AAUA;AACA;;;;;;;;;;;;;;;;;;;;;AAkBA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAnEA;AACA;AAoEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AAbA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AA3DA;AACA;;;;AAxDA;;AAsHA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AAHA;AACA;AAKA;;;;;;;;;;AAOA;AACA;AACA;AACA;AAFA;AAIA;;;;;;;;;;;AAQA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAJA;AAQA;AACA;AATA;AACA;AAWA;AACA;AACA;AADA;AAGA;AACA;AADA;AAJA;AAQA;AACA;AATA;AAbA;AACA;AAyBA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AADA;AAGA;;;;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAFA;AAIA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AAFA;AAIA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AAFA;AAFA;AAOA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AASA;;;;AAlYA;;;;;;;;;AA2YA;AACA;AAIA;AADA;AAJA;;;;;;;;;;;;;;;;ACrZA;;;;;;;;;AAMA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAjCA;AACA;AAgCA;AACA;AACA;AAHA;AACA;;;;;;;;AAjCA;;AA2CA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;;;;AAnIA;;;;;;;;;;AA6IA;AAAA;AAAA;;;;;;;;;;;;;;;;AC7IA;;;;;;;;;AAMA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AA1BA;AACA;AAyBA;AACA;AACA;AAHA;AACA;;;;;;;;AA1BA;;AAoCA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;AAQA;AACA;;;;AAnFA;;;;;;;;;;AA6FA;AAAA;AAAA;;;;;;;;;;;;;;;AC7FA;AACA;;;AACA;;;;;;;;;AAMA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAjCA;AACA;AAgCA;AACA;AADA;AAGA;AACA;AACA;AANA;AACA;AAjCA;;;;;;;;;;;;;;;;;;ACFA;AACA;;;;;;;AACA;;;;;;;;;;;AAMA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AACA;;;AADA;AACA;AA3FA;AACA;AADA;AACA;AA2FA;AACA;AACA;AAJA;AACA;;;;;;;;AA3FA;;AAsGA;AACA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;AASA;AACA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;;;;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;;;;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;;;;AAnSA;;;;;;;;;;AA6SA;AAAA;AAAA;;;;;;;;;;;;;;;;;AC/SA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAKA;AACA;AAMA;;;;;;;;;;;;;;AAYA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AADA;AACA;AAbA;AACA;AADA;AACA;AAaA;AACA;AACA;AADA;AAGA;AADA;AAGA;AACA;AACA;AACA;AACA;AAZA;AACA;;;;;;;AAbA;;AA+BA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;;;;AAGA;AACA;;;;;;;;;;AAOA;AACA;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;AANA;AAQA;AADA;AAGA;;;;;;;;;;;AAQA;AACA;;;;AA1EA;;;;;;;;;;;;;;;;;ACfA;;;;;;;;;AAMA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AAxBA;AACA;AAuBA;AACA;AACA;AACA;AAJA;AACA;;;;;;;AAxBA;;AAkCA;AACA;AACA;AACA;AADA;AAGA;;;;;;;;;;AAOA;AACA;AACA;AACA;AADA;AAGA;;;;;;;;;;;AAQA;AACA;AACA;AADA;AAGA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AADA;AADA;AAKA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;AA7FA;;;;;;;;;;;;;;ACAA;AACA;;;AAAA;AACA;;;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AADA;AAGA;AAJA;AAPA;AAcA;AAfA;;;;;;AAsBA;AACA;AACA;AACA;AACA;AADA;AADA;AAKA;AACA;AARA;;;;;;;AAgBA;AACA;AACA;AACA;AADA;AADA;AAKA;AANA;;;;;;;;;AAgBA;AACA;AACA;AAFA;AACA;;;;;;AASA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;AACA;AAhGA;;;;;;;;;;;;;;;ACHA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AAKA;AACA;AAKA;AACA;;;;;;;;AAOA;AAAA;AACA;AADA;AACA;AATA;AACA;AASA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AACA;;;;;;;;AATA;;AAyCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAHA;AAKA;;;;;;;;;;AAOA;AACA;;AADA;AAIA;AACA;AACA;;AAFA;AAKA;AANA;AAQA;;;;AAzEA;;;;;;;;;;;;;;ACfA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AARA;AACA;AAiBA;AACA;AADA;AACA;AAGA;AA1BA;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAnCA;AACA;;;;;AAoDA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAXA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AATA;;;;;;;;;;;;;;;;;AC1EA;AACA;;;AAAA;AACA;AAAA;AACA;;;;;AACA;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;AAAA;AACA;AAvEA;AACA;AAsEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AAXA;AACA;;;;;;;AAvEA;;AAyFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;;;;;;;;;;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AAjBA;;;;;;;;;;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAFA;AA1BA;;;;;;;;;;;AAsCA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;;;;;;;;;;AAOA;AACA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AANA;AAUA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AADA;AAGA;;;;;;;;;;AAOA;AACA;AAKA;;;;;;;;;;AAOA;AACA;AAKA;;;;;;;;;;;AAQA;AACA;AACA;AADA;AAGA;AACA;AADA;AACA;AAGA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AACA;AAGA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;;AADA;AAWA;AADA;;AAVA;AAeA;;AADA;;AAIA;AAJA;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AADA;AAGA;AAHA;;;;;;;;;;;;AAaA;AACA;AACA;;AADA;AAIA;AADA;AAGA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AADA;AADA;AAKA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAHA;;;;;;;;;;;AAcA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AANA;AAQA;AACA;AACA;AADA;AAGA;AAZA;AAcA;AAdA;AAgBA;;;;;;;;;;;AAQA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AADA;AAGA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AALA;AACA;AASA;AACA;AADA;AAXA;AAeA;;AADA;AAIA;AAJA;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AADA;AAGA;AACA;AAJA;;;;;;;;;;;;AAcA;;AAEA;AACA;AADA;AAGA;AADA;AAGA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AALA;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AALA;;;;;;;;;;;AAcA;;AAEA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAVA;AAaA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AAHA;AACA;AAKA;;;;;;;;;;AAOA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAGA;AAPA;AASA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AADA;AADA;AACA;AAKA;AACA;AADA;AAPA;AAWA;AACA;AACA;;AAHA;;AAOA;AACA;AADA;AAPA;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AADA;AAGA;AAHA;AAKA;AAPA;AASA;AACA;AADA;AAGA;AAHA;AAKA;AAdA;AAgBA;AAhBA;;;;;;;;;;;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AATA;AAYA;;;AADA;AAKA;AACA;AADA;AAGA;AAJA;AAMA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AANA;AACA;AAUA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;AAJA;AAOA;AACA;AADA;AAGA;AADA;;AAHA;AAQA;AACA;AADA;AAGA;AADA;AAGA;AAbA;AAeA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAFA;AAFA;AAOA;;;;;;;;;;;;AASA;AACA;;;;;;;;;;;AAQA;AACA;;;;;;;;;;;;;;AAWA;AACA;AACA;AADA;AAGA;AAHA;AAKA;;;;;;;;;;;;AASA;AACA;AACA;AADA;AAGA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;;AAHA;AAMA;;AADA;AAIA;AADA;AACA;;AATA;AAcA;;AADA;AAIA;AADA;AACA;AAGA;;;;;;;;;;;;AASA;AACA;;;;;;;;;;;;AASA;AACA;;;;;;;;;;;;AASA;AACA;;;;;;;;;;;;AASA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AADA;AAGA;;;;AAt9BA;;;;;;","sourceRoot":""}